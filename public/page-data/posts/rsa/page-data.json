{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/rsa/","result":{"data":{"markdownRemark":{"id":"bc9abb1d-d79f-57df-8a8f-dad5b22ce077","html":"<p>鍵交換アルゴリズムとしてはすでに<a href=\"https://wired.jp/2019/09/05/rsa-encryption-signature-validation-flaws/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">脆弱性</a>が見つかっており、めっちゃ使われているという実績のみでCRYPTRECの運用監視暗号リストにへばりついているRSA暗号なわけですが、電子署名の、特に<a href=\"http://blog.livedoor.jp/k_urushima/archives/1721840.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">署名検証においてはまだまだ現役</a>です。多分。</p>\n<p>というわけで、手軽に感動できるRSA暗号の実際の計算をやってみるとともに、最後におまけでRSAがもたらす誤解を紹介したいと思います。</p>\n<h2 id=\"データ受信者が秘密鍵を用意する\" style=\"position:relative;\"><a href=\"#%E3%83%87%E3%83%BC%E3%82%BF%E5%8F%97%E4%BF%A1%E8%80%85%E3%81%8C%E7%A7%98%E5%AF%86%E9%8D%B5%E3%82%92%E7%94%A8%E6%84%8F%E3%81%99%E3%82%8B\" aria-label=\"データ受信者が秘密鍵を用意する permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>データ受信者が秘密鍵を用意する</h2>\n<p>まずデータ受信者は2つの<strong>互いに素</strong>な<strong>素数</strong>p,qを秘密鍵として用意します。実際の実装では1000桁ほどの大きな素数を扱うのですが、この場合は単純化して<code class=\"language-text\">p = 5, q = 11</code>とします。</p>\n<p>当然秘密鍵なのでこの二つの素数は秘密にしておかなければなりません。ブラウザのJavaScriptに書くとかダメ。絶対。</p>\n<h2 id=\"データ受信者が公開鍵を用意する\" style=\"position:relative;\"><a href=\"#%E3%83%87%E3%83%BC%E3%82%BF%E5%8F%97%E4%BF%A1%E8%80%85%E3%81%8C%E5%85%AC%E9%96%8B%E9%8D%B5%E3%82%92%E7%94%A8%E6%84%8F%E3%81%99%E3%82%8B\" aria-label=\"データ受信者が公開鍵を用意する permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>データ受信者が公開鍵を用意する</h2>\n<p>再びデータ受信者が2つの公開鍵を用意します。1つ目は先ほど用意した2つの秘密鍵を掛けた数値n。つまり</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">n = p * q = 5 * 11 = 55</code></pre></div>\n<p>もう1つは任意の正の整数eです。実際の通信では<code class=\"language-text\">2^16 + 1 = 65537</code>が使われることが多いですが、今回は単純化して<code class=\"language-text\">e = 3</code>とします。</p>\n<h2 id=\"データ受信者が復号のための鍵を用意する\" style=\"position:relative;\"><a href=\"#%E3%83%87%E3%83%BC%E3%82%BF%E5%8F%97%E4%BF%A1%E8%80%85%E3%81%8C%E5%BE%A9%E5%8F%B7%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E9%8D%B5%E3%82%92%E7%94%A8%E6%84%8F%E3%81%99%E3%82%8B\" aria-label=\"データ受信者が復号のための鍵を用意する permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>データ受信者が復号のための鍵を用意する</h2>\n<p>まだ終わりではありません。データ受信者は今度は自分に送られてきた暗号文を復号するための鍵dを用意します。\n具体的な算出方法は以下の通り。</p>\n<h3 id=\"復号鍵dの求め方\" style=\"position:relative;\"><a href=\"#%E5%BE%A9%E5%8F%B7%E9%8D%B5d%E3%81%AE%E6%B1%82%E3%82%81%E6%96%B9\" aria-label=\"復号鍵dの求め方 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>復号鍵dの求め方</h3>\n<p>まず(p-1)と(q-1)の最小公倍数Lを求めます。</p>\n<p><a href=\"https://mathtrain.jp/euclid#:~:text=%E3%83%A6%E3%83%BC%E3%82%AF%E3%83%AA%E3%83%83%E3%83%89%E3%81%AE%E4%BA%92%E9%99%A4%E6%B3%95%EF%BC%88%E3%81%94,%E7%B4%A0%E6%97%A9%E3%81%8F%E8%A8%88%E7%AE%97%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95%E3%81%A7%E3%81%99%E3%80%82\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ユークリッドの互除法</a>を使ってp-1, q-1の最大公約数gを求めます。今回は4と10の最大公約数なので<code class=\"language-text\">g = 2</code>となります。Lは<strong>p-1とq-1の最小公倍数</strong>なので、</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">L = (p - 1) * (q - 1) / g = 4 * 10 / 2 = 20</code></pre></div>\n<p>になります。</p>\n<p>＊今回の場合は簡単な整数なので暗算で最小公倍数を求めることができたかもしれませんが、実際の数値はもっと大きく、ユークリッドの互除法を用いて最大公約数を求めた後にそれを使って最小公倍数を求めることになります。</p>\n<p>Lが求まったら、復号鍵dが求まります。復号鍵dの算出方法は</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">d = d * e - y * L = 1 の自然解</code></pre></div>\n<p>今回の場合<code class=\"language-text\">e = 3, L = 20</code>なので</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">d = 3d - 20y = 1 の自然解 ∴ d = 7, y = 1</code></pre></div>\n<p>となり、dが7になります。</p>\n<p>これで鍵の用意は完了なので、いよいよ暗号と復号に入ります。</p>\n<h2 id=\"平文の暗号化\" style=\"position:relative;\"><a href=\"#%E5%B9%B3%E6%96%87%E3%81%AE%E6%9A%97%E5%8F%B7%E5%8C%96\" aria-label=\"平文の暗号化 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>平文の暗号化</h2>\n<p>今回は文字列 “RSA” を暗号化したいと思います。まずは”R”を平文mとして暗号化します。暗号化の数式は以下の通りです。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">暗号文c = m^e mod n</code></pre></div>\n<p>RをUS-ASCII変換すると52なので</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">c = 52^3 mod 55 = 28</code></pre></div>\n<p>この要領で”S”,“A”も暗号化すると、Sは47、Aは6になります。この時点で各バイト数を文字列に変換すると”(G\tACK”になり、これが暗号文になります。いい感じに暗号っぽくなってますね。</p>\n<h2 id=\"暗号文の復号\" style=\"position:relative;\"><a href=\"#%E6%9A%97%E5%8F%B7%E6%96%87%E3%81%AE%E5%BE%A9%E5%8F%B7\" aria-label=\"暗号文の復号 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>暗号文の復号</h2>\n<p>上記の方法で送信者が暗号化した文を今度は受信者が復号します。復号の数式は以下の通りです。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">平文m = C^d mod n</code></pre></div>\n<p>一文字ずつ復号してくと、</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># \"(\"の28を復号</span>\n<span class=\"token number\">28</span><span class=\"token operator\">^</span><span class=\"token number\">7</span> mod <span class=\"token number\">55</span> <span class=\"token operator\">=</span> <span class=\"token number\">52</span>\n<span class=\"token comment\"># \"G\"の47を復号</span>\n<span class=\"token number\">47</span><span class=\"token operator\">^</span><span class=\"token number\">7</span> mod <span class=\"token number\">55</span> <span class=\"token operator\">=</span> <span class=\"token number\">53</span>\n<span class=\"token comment\"># \"ACK\"の6を復号</span>\n<span class=\"token number\">6</span><span class=\"token operator\">^</span><span class=\"token number\">7</span> mod <span class=\"token number\">55</span> <span class=\"token operator\">=</span> <span class=\"token number\">41</span></code></pre></div>\n<p>それぞれ文字列に変換すると”RSA”に戻ってますね。ここで確認しておきたいのが、送信者は公開鍵しか使っていないという点です。eもnも一般に公開される公開鍵ですので、送信者も使用できます。一方受信者は秘密鍵であるp,qから作成したLから作成した、実質的に秘密鍵であるdを使って復号をしています。これにより、受信者のみが復号できる暗号通信が完成します。</p>\n<h2 id=\"rsaがもたらす誤解\" style=\"position:relative;\"><a href=\"#rsa%E3%81%8C%E3%82%82%E3%81%9F%E3%82%89%E3%81%99%E8%AA%A4%E8%A7%A3\" aria-label=\"rsaがもたらす誤解 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RSAがもたらす誤解</h2>\n<p>RSAは、一つの公開鍵について秘密鍵が一つに定まる<a href=\"https://en.wikipedia.org/wiki/Deterministic_encryption\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><strong>確定的暗号</strong></a>です(文献英語しかなかった…)。固定長のデータを一単位として暗号化する<a href=\"https://qiita.com/shoichi0599/items/6082b765c1257b71985b\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ブロック暗号</a>も確定的暗号だったりするのですが、一つの公開鍵についても動的に秘密鍵が変化する<strong>確率的暗号</strong>も存在します。しかし上述の通りRSA暗号の暗号化と復号の数式が</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">c = m^e mod n\nm = c^d mod n</code></pre></div>\n<p>と対になっているがために「暗号アルゴリズムの指数のeとdを逆にすれば署名にも使えるんじゃね？」と一般化した誤解が生まれてしまったのです。しかし、このような暗号化と復号のアルゴリズムにおける対称性があるのはRSA暗号だけであり、なおかつ近年主流になっている<a href=\"https://zoom-blc.com/what-is-ecdsa\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ECDSA</a>や、主流ですらないDSAやGOSTなど、RSA以外の電子署名暗号方式は公開鍵暗号方式をベースにしたものではありません。よって、「電子署名とは、公開鍵暗号方式の秘密鍵で暗号化することである」というのは<strong>紛れもない間違い</strong>であることは頭の片隅に置いておいてください。</p>\n<hr>\n<p>参考になれば幸いです。</p>\n<h2 id=\"参考\" style=\"position:relative;\"><a href=\"#%E5%8F%82%E8%80%83\" aria-label=\"参考 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>参考</h2>\n<p><a href=\"http://blog.livedoor.jp/k_urushima/archives/1721840.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://blog.livedoor.jp/k_urushima/archives/1721840.html</a>\n<a href=\"https://qiita.com/angel_p_57/items/d7ffb9ec13b4dde3357d\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://qiita.com/angel_p_57/items/d7ffb9ec13b4dde3357d</a>\n<a href=\"https://qiita.com/shoichi0599/items/6082b765c1257b71985b\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://qiita.com/shoichi0599/items/6082b765c1257b71985b</a>\n<a href=\"https://medium.com/blockchain-engineer-blog/%E7%A7%81%E3%81%AF%E5%85%AC%E9%96%8B%E9%8D%B5%E6%9A%97%E5%8F%B7%E6%96%B9%E5%BC%8F%E3%81%A8%E9%9B%BB%E5%AD%90%E7%BD%B2%E5%90%8D%E3%82%92%E7%90%86%E8%A7%A3%E3%81%A7%E3%81%8D%E3%81%A6%E3%81%84%E3%81%AA%E3%81%8B%E3%81%A3%E3%81%9F%E3%82%88%E3%81%86%E3%81%A7%E3%81%99-af0894c3df0b\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://medium.com/blockchain-engineer-blog/%E7%A7%81%E3%81%AF%E5%85%AC%E9%96%8B%E9%8D%B5%E6%9A%97%E5%8F%B7%E6%96%B9%E5%BC%8F%E3%81%A8%E9%9B%BB%E5%AD%90%E7%BD%B2%E5%90%8D%E3%82%92%E7%90%86%E8%A7%A3%E3%81%A7%E3%81%8D%E3%81%A6%E3%81%84%E3%81%AA%E3%81%8B%E3%81%A3%E3%81%9F%E3%82%88%E3%81%86%E3%81%A7%E3%81%99-af0894c3df0b</a></p>","fields":{"slug":"/posts/rsa/","tagSlugs":["/tag/algorithm/","/tag/encryption/"]},"frontmatter":{"date":"2020-11-18","description":"RSA暗号の暗号化と復号をしてみようという話。実装に関してはまた後ほど","tags":["algorithm","encryption"],"title":"RSA暗号を計算する","socialImage":{"publicURL":"/static/732bbf5c4fdcc63ac39e10f8f82a3435/image-3.jpg"}}}},"pageContext":{"slug":"/posts/rsa/"}},"staticQueryHashes":["251939775","401334301","825871152"]}