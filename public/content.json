{"pages":[],"posts":[{"title":"Encoding, Encryption, Hashing, Obfuscationの意味","text":"ある日ネットサーフィンをしていたらEncoding vs. Encryption vs. Hashing vs. Obfuscationという記事を見つけた。この四つの単語はそれぞれ実際には全く違う意味なんだけど「違いを説明せよ」と突然言われたら確かに説明できないなぁ、と思ったので元記事の内容に沿って各単語の意味を整理しておきます。 各単語の概要Encodingデータをある一定の規則に基づいて可逆な別のデータに変換すること。和訳は符号化。 Encryptionデータをアルゴリズムを使って特定の「鍵」によって復号可能な別のデータに変換すること。和訳は暗号化。 Hashingデータをアルゴリズムを使って非可逆な別のデータに変換すること。和訳はハッシング。 Obfuscationデータの意味は変えないまま人間にとって読みにくい別のデータに変換すること。和訳は難読化。 Encoding 和訳 : 符号化 可逆 符号化は比較的幅広い分野で当てはまる概念である。脳科学においても符号化（記銘）という概念があり、言語の翻訳もある意味では符号化である。またカメラの画像処理やアナログ音声のA/D変換においても符号化の概念が利用されている。挙げていくとキリがなくてただでさえ短い夏休みが無駄になってしまうので全て調べ上げることはできないが、要するに、「あるデータを誰かにとって理解しやすいデータに規則正しく変換する」というのが符号化の意味である。この概念を応用した例としてはデータの圧縮なども挙げられる。 情報科学であればコンピュータ、脳科学であれば脳、言語学であればその国の人にとって理解しやすいデータの形を作ってあげるのが、符号化の仕事であり、概念である。この記事を見ているであろう技術者の方に馴染みのある例をあげればUnicodeやBase64、ASCIIなどが符号化データに当たる。&nbsp;&nbsp;上記で述べた概念を用いれば、DNSサーバーでURLをIPアドレスに変換する処理も、通信プロトコルが理解しやすいデータに変換するという意味では符号化に当てはまる。実際の通信では2進数でやりとりされるIPアドレスを人間様の読みやすいように10進数に変換する処理もまた、符号化である。 Encryption 和訳 : 暗号化 可逆 暗号化は主に情報通信において使われることが多い。暗号の起源として知られるものとして ヒエログリフ(象形文字)が挙げられるが、ヒエログリフそのものに秘匿性の意図はなく、単に後世で解読にえげつなく時間がかかったというだけなので厳密には暗号ではないとされている。古代から近代にかけては主に軍事的な目的で暗号が発明されることが多く、有名なシーザー暗号やドイツ軍のエニグマの暗号方式などもその一つである。古代の暗号から共通する目的として、データを秘密に保つことが挙げられる。これに関しては直感的に分かりやすいので詳しく説明する必要はないが、カッコよく言えば「秘匿性」である。&nbsp;&nbsp;現代の情報通信における暗号化では、一つの通信で使われる暗号アルゴリズムなどを、暗号スイートという文字列で表す。例えば、 1ECDHE-RSA-AES128-GCM-SHA256 という暗号スイートがあった場合、鍵交換にはECDHE、鍵認証にはRSA、暗号化アルゴリズムにはAES128、暗号モードはGCM、ハッシュ関数にはSHA-256が使われているということを示す。 ＊鍵認証と暗号化アルゴリズムの間に「_WITH_」が入る場合もある Hashing 和訳 : ハッシング 非可逆 ハッシングは主に情報通信で使われ、アルゴリズムに基づいてあるデータを一見乱数に見える解読不可能で非可逆な別のデータに変換することをいう。暗号化と違って秘匿性の目的はなく、主に検索の高速化や改竄検知に使われる。&nbsp;&nbsp;例えば、ハッシュ探索アルゴリズムは一般的な線形探索アルゴリズムに比べて高速な処理が期待でき、ハッシュを利用したLandmark-based fingerprintingはShazamの音声類似性検索のアルゴリズムにも採用されている。改竄検知でいえば、最も有名なのがSHA-1, SHA-2ハッシュ関数である。改竄検知の方法としてはデータをハッシュ化して暗号化したデータと共に送信し、受信側がデータを復号してハッシュ化した際に元のハッシュ値と違った場合に改竄が検出されるというものである。SHA-1に関しては2005年から脆弱性が指摘され、2017年にGoogleが実際に攻撃に成功したことが決定的となって利用は大幅に減少した。2020年7月にIPAから公開されたCRYPTRECの利用禁止暗号アルゴリズムにもノミネートされている。 Obfascation 和訳 : 難読化 可逆 難読化とは、主にソースコードの解析防止や知的財産権の保護を目的として敢えて読みにくいコードに変換することである。概念を説明すれば「誰かにとって扱いにくいデータに変換する」、つまり概念的には符号化の対極に位置するものとも言える。難読化がソースコードの文脈以外で使われている例はぶっちゃけ思いつかないし、ググっても出てこないので「難読化=ソースコードの難読化」と考えて良いだろう。&nbsp;&nbsp;ソースコードを難読化する理由としては、上述のように、実装している独自アルゴリズムのパクリや機能制限の回避を目的としたリバースエンジニアリングを防ぐ目的がほとんどである。実際JavaScriptやPythonなど、主要なスクリプト言語ほぼ全てに難読化パッケージ/ツールがあるが、手作業でやるのは単純に初心者がコードを書くのと一緒になってしまうので完全に時間の無駄である。 ＊筆者の場合は自分が書くコードは無意識に難読化されているので難読化ツールは特に必要ない。&nbsp;&nbsp;ここからは筆者の個人的な意見だが、個人プロジェクト以外のコードはほぼ確実に他人と共有する必要があり、その時に難読化されたコードをレビューしろとか改変しろとか言われたらたまったもんじゃない。なので本当に隠したい処理はサーバーサイドで書き、どうしてもクライアントサイドで書かなければならない場合は開発が終了して保守のフェーズに入る際に難読化することをお勧めする。 といった感じでできるだけ各単語の概念を踏まえて整理したので、参考にしていただけるとありがたいです。&nbsp;&nbsp;「ここ違うぜ」と思った方はコメントで教えていただけると非常に勉強になるので嬉しいです。 参考文献https://www.netagent.co.jp/study/blog/hard/20180726.html https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/ https://www.geeksforgeeks.org/encryption-encoding-hashing/ https://www.packetlabs.net/encryption-encoding-and-hashing/","link":"/2020/08/10/enword/"},{"title":"毎朝5時にGoogle Formに自動回答したい","text":"みなさんこんにちは。夏ですね。僕もついに部活動が再開し、ワクワクドキドキな訳ですが、一昨日の夜顧問からこんな連絡がきました。 12- 毎朝5時20分までに検温を行い、結果をGoogleFormから報告してください- 報告がなかった部員は朝練の参加を認めません そもそも朝練が6時半から始まる時点でイッているので5時20分に連絡しろと言われてもさほど驚かなかったのですが、ここで一つ問題が発生しました。 というのも僕は普段朝5時に起き、そのままパンをかじりながら自転車で駅に向かうので、検温をする時間がないのです。もう少し早起きすれば済む話なのですが、4時起きは流石にきついし体がもたないのでやりたくない。かといって5時に起きて検温なんかしていたら朝練そのものに遅れてしまう。 というわけで、朝5時くらいに、心配されない程度の体温をよしなに指定のFormに入力して送信してくれるプログラムを作りたいと思います。 Seleniumでフォームを送信する本物のフォームを使ってやると僕の身元がバレてしまうので、今回はテスト用に僕が作成した本物と同じ内容のフォームで実装したいと思います。 初期値入力つきURLを用意するGoogle Formは、パラメータをつけることで各質問の値を入力した状態でURLを開くことができます。普通にフォームを開く際のURLは https://docs.google.com/forms/d/e/1FAIpQLScGgZ8dsBkcSVutvW3JgDLqy3pIEKk12ucjiA8mNQrKopILog/viewform?usp=sf_link こんな感じでviewformの後に「usp=sf_link」というパラメータがついています。このパラメータは事前入力のない、ピュアな回答フォームであることを示しているので、まずここを「usp=pp_url」に変えて、事前入力があることを知らせてあげます。&nbsp;&nbsp;そしたら次に各質問の回答をパラメータに入力していきます。フォームの各質問を識別する番号があるので、Chromeの検証画面で質問のdivを探し、2階層目で以下のような番号を探します。番号を見つけたらentry.番号=回答内容の形でパラメータを加えます。今回は名前と体温をテキストで入力するので以下のようなURLになります。 https://docs.google.com/forms/d/e/1FAIpQLScGgZ8dsBkcSVutvW3JgDLqy3pIEKk12ucjiA8mNQrKopILog/viewform?usp=pp_url&amp;entry.1534939278=荒川智則&amp;entry.511939456=36.5しかしこのままだと毎日36.5度を報告することになり、流石に怪しまれるので、乱数で良い感じに値を振ります。 1234# 36.1~36.7の間でランダムに値を生成して文字列変換body_temp = str(36 + random.randint(1,7)/10)# URLの最後に加えるurl = 'https://docs.google.com/forms/d/e/1FAIpQLScGgZ8dsBkcSVutvW3JgDLqy3pIEKk12ucjiA8mNQrKopILog/viewform?usp=pp_url&amp;entry.1534939278=荒川智則&amp;entry.511939456='+body_temp Seleniumで自動提出URLが完成したら、あとはSeleniumでURLを開き、ポチッと提出ボタンを押してもらうだけです。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# SeleniumとChromedriverをpipでインストールしておくfrom selenium import webdriverimport chromedriver_binaryimport timeimport randombody_temp = str(36 + random.randint(1,7)/10)url = 'https://docs.google.com/forms/d/e/1FAIpQLScGgZ8dsBkcSVutvW3JgDLqy3pIEKk12ucjiA8mNQrKopILog/viewform?usp=pp_url&amp;entry.1534939278=荒川智則&amp;entry.511939456='+body_temp# クリックの関数def click(xpath): driver.find_element_by_xpath(xpath).click()# パスワード入力の関数def insert_pw(xpath, str): driver.find_element_by_xpath(xpath).send_keys(str)driver = webdriver.Chrome()driver.implicitly_wait(1)driver.get(url)moving_login_button = '/html/body/div[2]/div/div[2]/div[3]/div[2]'time.sleep(1)# Googleアカウントでのログインが必要な場合はログインするif(driver.find_elements_by_xpath(moving_login_button) != []): click(moving_login_button) login_id = \"{Googleアカウントのメアド}\" login_id_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[1]/div/form/span/section/div/div/div[1]/div/div[1]/div/div[1]/input' login_id_button = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[2]/div/div[1]/div/div' insert_pw(login_id_xpath, login_id) click(login_id_button) time.sleep(1) login_pw = \"{Googleアカウントのパスワード}\" login_pw_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[1]/div/form/span/section/div/div/div[1]/div[1]/div/div/div/div/div[1]/div/div[1]/input' login_pw_button = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[2]/div/div[1]/div/div' insert_pw(login_pw_xpath, login_pw) time.sleep(1) click(login_pw_button)time.sleep(1)submit_button = '//*[@id=\"mG61Hd\"]/div[2]/div/div[3]/div[1]/div/div'click(submit_button)print(\"Done!\")driver.close# メモリーを食うのでちゃんと終了しましょうdriver.quit しっかり送信できました。 定期イベントにするコードが書けたらあとは定期イベント化するだけなのですが、ここで少しつまづいたのでやり方を説明しておきます。&nbsp;&nbsp;当初予定していた方法としてはAutomatorでアプリ化し、カレンダーに入れて毎日実行する方法(参考)。これなら報告しなくて良い日はカレンダーから外せば良いし、完璧なはず。と思ったのですが、PCをシャットダウンしていると動作しないためボツ。crontabに設定して定期イベント化する方法も同様の理由でボツ。 結局臨機応変にイベントの変更はできないものの、PCの状態にかかわらず実行してくれるAWSのLambdaを使用することに決めました。(Lambdaの使い方はこのサイトとかが参考になりました) LambdaのレイヤーにSeleniumとChromedriver、headless-chromiumを上げるLambdaでライブラリを使うには各フォルダをzipに圧縮してレイヤーにアップロードする必要があります。今回はSeleniumとChromeのWebdriverであるChromedriver、それからChromeを開かずにスクレイピングを行うためのheadless-chromiumを使用するので、それぞれzipに圧縮してレイヤーに上げていきます。 1. Selenium1234567mkdir seleniumcd seleniummkdir pythoncd pythonpip install selenium -t .cd ../zip -r selenium.zip ./python できたzipファイルをそのままレイヤーにアップロードします。 2. Chromedriverとheadless-chromium12curl https://github.com/adieuadieu/serverless-chrome/releases/download/v1.0.0-55/stable-headless-chromium-amazonlinux-2017-03.zip &gt; headless-chromium.zipcurl https://chromedriver.storage.googleapis.com/2.43/chromedriver_linux64.zip &gt; chromedriver.zip できた二つのzipファイルを解凍し、headless-chromeフォルダにまとめます。その後そのheadless-chromeをzipに圧縮してレイヤーにアップロードします。 3. レイヤーを関数に適用関数の下にある「Layers」を押し、下の「レイヤーの追加」ボタンから二つのレイヤを追加します ※注意※ Lambda関数のランタイムをPython3.8にするとChromedriverが動いてくれなかった(原因不明)ので、ランタイムはPython3.6か3.7に設定することをお勧めします。 headless-chromiumとChromedriverの間に互換性がないと動作しないのでこちらから最新版を入手しても動作しない可能性があります。 Lambda用にコードを少し変える筆者は今までCloud9以外のAWSツールを使ったことがないへっぽこコーダーなので、色んなサイトの見様見真似でなんとかLambdaで動くコードにしました。先人に感謝。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import jsonfrom selenium import webdriverimport timeimport randomdef lambda_handler(event, context): body_temp = str(36 + random.randint(1,7)/10) url = 'https://docs.google.com/forms/d/e/1FAIpQLScGgZ8dsBkcSVutvW3JgDLqy3pIEKk12ucjiA8mNQrKopILog/viewform?usp=pp_url&amp;entry.1534939278=荒川智則&amp;entry.511939456='+body_temp options = webdriver.ChromeOptions() options.binary_location = '/opt/headless-chrome/headless-chromium' # このオプション4つを付けないとChromeは起動せずエラーになります options.add_argument('--headless') # サーバーレスでChromeを起動 options.add_argument('--no-sandbox') # sandbox外でChromeを起動 options.add_argument('--single-process') # タブ/サイトごとのマルチプロセスではなく、シングルプロセスへ切り替える options.add_argument('--disable-dev-shm-usage') # メモリファイルの出力場所を変える driver = webdriver.Chrome('/opt/headless-chrome/chromedriver',options = options) driver.implicitly_wait(1) driver.get(url) def click(xpath): driver.find_element_by_xpath(xpath).click() def insert_pw(xpath, str): driver.find_element_by_xpath(xpath).send_keys(str) moving_login_button = '/html/body/div[2]/div/div[2]/div[3]/div[2]' time.sleep(2) if(driver.find_elements_by_xpath(moving_login_button) != []): click(moving_login_button) # 環境変数でMY_GMAILにGoogleアカウントのメアドを設定してください login_id = MY_GMAIL login_id_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[1]/div/form/span/section/div/div/div[1]/div/div[1]/div/div[1]/input' login_id_button = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[2]/div/div[1]/div/div' insert_pw(login_id_xpath, login_id) click(login_id_button) time.sleep(1) # 環境変数でMY_PASSWORDにGoogleアカウントのパスワードを設定してください login_pw = MY_PASSWORD login_pw_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[1]/div/form/span/section/div/div/div[1]/div[1]/div/div/div/div/div[1]/div/div[1]/input' login_pw_button = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[2]/div/div[1]/div/div' insert_pw(login_pw_xpath, login_pw) time.sleep(1) click(login_pw_button) time.sleep(1) submit_button = '//*[@id=\"mG61Hd\"]/div[2]/div/div[3]/div[1]/div/div' click(submit_button) driver.close driver.quit return { 'statusCode': 200, 'body': json.dumps('Form submission success!!') } 注意点 Chromeの起動オプション--headless,--no-sandbox,single-process,--disable-dev-shm-usageを付けないとLambda上で正常に起動せず、エラーが出ます。各オプションについての詳細はこちらをご覧ください レイヤーにアップロードしたファイルはoptディレクトリの配下に置かれます。パスを指定する際はopt/ディレクトリ名/…の形で表記しましょう CloudWatch Eventsでトリガーを設定 関数の「Layers」をクリックして「トリガーを追加をクリック」し、ドロップダウンから「EventBridge (CloudWatch Events)」を選択します。 ルールは「新規ルールの作成」で任意のルール名を入力。ルールタイプをスケジュール式にし、今回は毎日朝5時なのでcorn(0 20 ? * * *)と入力(LambdaはUTCでトリガーされるので9時間前をセットすることに留意)。トリガーを有効にして「追加」をクリックします。（cronの書き方はこちらをご覧ください） テスト最後にしっかり動くかテストしましょう。Lambda関数画面の「テスト」をクリックします。大丈夫そうですね。 おわりに朝の検温はサボっていますが、寝る前にちゃんと測っているので安心してください。 参考文献https://masakimisawa.com/selenium_headless-chrome_python_on_lambda/https://github.com/heroku/heroku-buildpack-google-chrome/issues/56https://qiita.com/mishimay/items/afd7f247f101fbe25f30","link":"/2020/08/11/gfa/"},{"title":"Font Access APIを使う","text":"Chrome87よりブラウザ上でインストール済みのフォントを調べるFont Access APIがOrigin Trialsに公開されました。正直このAPIで何か作ろうとは思っていませんが、このAPIを欲するいつの日かのために少し調べたので書き残しておきます。 Quick StartOrigin Trialsでトークンを取得するOrigin Trialsを利用したことがある方は飛ばして大丈夫です。まずはChrome FlagsのFont Access APIをenableに変更します。その後Origin TrialsページのLocal Font AccessをRegisterします。するとトークンが発行されますので 1&lt;meta http-equiv=\"origin-trial\" content=\"ここにトークンを貼る\"&gt; このmetaタグをソースコードに挿入します。 APIが使えるかどうかまずこのAPIが使用できるかどうかを確認しておきましょう。 12345678if(!'fonts' in navigator) return;const status = await navigator.permissions.query({ name: \"font-access\" }); if (status.state === \"granted\") console.log(\"permission was granted 👍\"); else if (status.state === \"prompt\") console.log(\"permission will be requested\"); else console.log(\"permission was denied 👎\"); Chrome87以上であれば問題ありませんがそうでないブラウザの場合は他の処理で代用するしかないでしょう。 フォントオブジェクトを取得する1const iterableFontObject = navigator.fonts.query(); この変数には非同期イテレータ(Asynchronous Iterator)が代入されます。つまりfor await ofでイテレート処理ができるわけです。 メタデータを取得する123456for await (const metadata of iterableFontObject) { const fontFamily = metadata.family; // e.g.ComicSansMS const postscriptName = metadata.postscriptName; // e.g.Comic Sans MS const fullName = metadata.fullName; // e.g.Comic Sans MS console.log(fontFamily, postscriptName, fullName);} 現状文字列として取得できるデータはこの3つのようです。postscriptNameは確実にユニークで、OpenTypeフォーマットでなくてもUserAgentがよしなに導出してくれるようです。非同期イテレータはObject.keys().lengthではフォント数の算出はできないので、イテレートついでに数えておくのが一番手っ取り早いかと。 SFNTデータにアクセスするTrueType, OpenType, WOFFなどが得られるというわけです。これに関してはまじで使い道が分からん。とりあえず実装していきます。123456789## SFNTバージョンを取得する```javascriptconst fonts = navigator.fonts.query();for await (const metadata of fonts) { const sfnt = await metadata.blob(); const sfntVersion = (new TextDecoder).decode( await sfnt.slice(0, 4).arrayBuffer() );} 1234567891011121314151617ただこのままではなんのデータか分からないので拡張子形式に変換していきましょう。```javascriptfor await (const metadata of fonts) { let outlineFormat = 'UNKNOWN'; switch (sfntVersion) { case '\\x00\\x01\\x00\\x00': case 'true': case 'typ1': outlineFormat = '.ttf'; break; case 'OTTO': outlineFormat = '.cff'; break; } console.log('Format Extension:', outlineFormat, metadata.family);} 現在AppleでサポートされているフォントはTrueType(.ttf)かPostscript(.cff)のどちらかなので、それに合わせてSFNTバージョンを絞っていきます。これまじで何に使うんだろうか。 セキュリティの懸念と対策最近File System Access APIなどローカルのシステムにアクセスするAPIが増えていますが、やはり怖いのはセキュリティです。 フィンガープリント対策Font Access APIは取得したフォントをアルファベット順にソートして返します。これは、システムにインストールされた順番のままフォントのリストを返してしまうと、フィンガープリントに利用され、ユーザーの識別に使われる可能性が高いからです。数百のフォントを全く同じ順番でインストールする複数のユーザーなどそういないですからね。 リクエストシステム最初の方のパーミッションリクエストの部分がこれです。メタタグを使用してリクエストを送信しない限り使用できないようにすることでAPIの濫用を防いでいます。https://chromium.googlesource.com/chromium/src/+/lkgr/docs/security/permissions-for-powerful-web-platform-features.md (この記事でも先述のFile System Access APIがケーススタディとして紹介されています)ただ、最初にメタタグなしでパーミッション確認もなしで実行してみたところ普通に動いてしまったので、筆者も???となっているところです。 ユーザーの実行動作実はこのAPIは今までのコードを非同期即時関数に入れただけでは動きません。ロードしたら自動的に動作することを許可すると大抵良いことはないので、ボタンをクリックする、何かのキーを打つなどユーザーが自ら実行することでしか動かないような仕様になっています。(e.g.~.addEventListner()) 確認ダイアログの表示このAPIを実行する動作をユーザーが行うと、このダイアログが表示されます。これは他のローカルにアクセスするAPIでも同様の仕様のものが多いです。 デモとソースコードChromeのWebDevチームがGlitchにデモサイトとコードを公開しています。 https://local-font-access.glitch.me/demo/ ほぼ似たようなものですが僕の書いたソースコードも投げておきます。 Quick Startの方12345678910111213141516171819const AccessFont = async () =&gt; { const status = await navigator.permissions.query({ name: \"font-access\" }); if (status.state === \"granted\"){ console.log(\"permission was granted 👍\"); } else if (status.state === \"prompt\") { console.log(\"permission will be requested\"); } else { console.log(\"permission was denied 👎\"); } const iterableFontObject = navigator.fonts.query(); let total = 0; for await (const metadata of iterableFontObject) { console.log(metadata.fullName); total++; } console.log(`Total number of local fonts : ${total}`);}const button = document.getElementById(\"test\");button.addEventListener(\"click\", AccessFont); // ユーザーの動作がないと動かせない SFNTアクセスの方1234567891011121314151617181920212223const AccessSFNT = async () =&gt; { const fonts = navigator.fonts.query(); for await (const metadata of fonts) { const sfnt = await metadata.blob(); const sfntVersion = (new TextDecoder).decode( await sfnt.slice(0, 4).arrayBuffer() ); let outlineFormat = 'UNKNOWN'; switch (sfntVersion) { case '\\x00\\x01\\x00\\x00': case 'true': case 'typ1': outlineFormat = '.ttf'; break; case 'OTTO': outlineFormat = '.cff'; break; } console.log('Format Extension:', outlineFormat, metadata.family); }}const access = document.getElementById(\"access\");access.addEventListener(\"click\", AccessSFNT); // ユーザーの動作がないと動かせない 終わりに最初に記事を書いたときは本気で何に使うのか分からないAPIでしたが、どうやらFigmaとかその他デザインアプリケーション、CADに特化したフォントをWebで使う際に役立つようです。 Bringing design apps like Figma, Gravit, and Photopea, to the web is great.For example, corporate logo fonts, or specialized fonts for CAD and other design applications. https://developers.google.com/web/updates/2020/11/nic87#font-access 参考文献WICG仕様書 Web.devチームブログ(最初に読むならこれ) Web.devチームGlitchデモ Chrome87の新機能まとめ(公式) Chrome Platform Status APIのパーミッションに関するChromeの文献 https://nixeneko.hatenablog.com/entry/2018/06/20/000000","link":"/2020/12/04/faaapi/"},{"title":"File System Access APIを使ってみる","text":"以前までChromeのOrigin TrialsにNative File System APIとして実装されていたローカルファイルへアクセスするAPIが、ついにChrome86から標準機能として搭載され、名前も実装もだいぶ変わっていたので記事に残しておきます。 このAPIはChromeバージョン86以降のみ対応しています。他ブラウザ、Chrome85以前では動きませんのでプロダクション環境に実装する予定の方はご注意ください（というかおやめください）。 File System Access APIFile System Access APIは主にローカルファイルの読み取り、書き取りを目的としたAPIです。実はファイルだけでなくフォルダの読み取り/書き取りもできますが、今回はファイルの読み取り/書き取りの方法を紹介します。 ファイルを読み取るこれまでローカルファイルを読み取るにはこの記事みたいに自分でHTMLタグを足したり、ファイル内容を切ったり貼ったりする必要があり、かなり面倒くさい実装が不可欠でした。一方File System Access APIではたった３行で読み込みが完了します。 123[fileHandle] = await window.showOpenFilePicker();const file = await fileHandle.getFile();const fileContents = await file.text(); このfileContentsをtextareaに代入すれば手軽にファイルの読み取りが完了します。 読み取りオプション１行目のshowOpenFilePickerは引数でオプションの設定も可能です。 1234// 複数ファイルの選択を可能にする[fileHandle] = await window.showOpenFilePicker({multiple: true});// 複数ファイルの選択を不可能にする[fileHandle] = await window.showOpenFilePicker({multiple: false}); 参考 fileHandleの中身12345678{ lastModified: 1587625257478 // ファイル最終更新日時(UNIXタイム) lastModifiedDate: Thu Apr 23 2020 16:00:57 GMT+0900 (日本標準時) {} // ファイル最終更新日時 name: \"sample.pdf\" // ファイル名 size: 85488 // ファイルサイズ (単位はバイト) type: \"application/pdf\" // ファイルタイプ （記述のない場合もある） webkitRelativePath: \"\" // フォルダを選択した際に内部のファイル数などを表示できる} ファイルに書き込む従来のブラウザではそもそも上書きすることが不可能だったのですが、こちらもFile System Access APIでは簡単に書けちゃうんです。 123const writable = await fileHandle.createWritable();await writable.write(contents/*⇦書き込む内容*/);await writable.close(); さっきファイル情報を代入したfileHandleにcreateWritableメソッドでFileSystemWritableFileStreamオブジェクトを呼び出します。その後書き込んで、終了するだけ。非常に簡潔な仕様です。 この時ブラウザではこんな感じのダイアログが表示され、「変更を保存」ボタンを押すとローカルファイルの上書きが完了します これ以降、新たなファイルを読み込むかリロードや手動でfileHandleをリセットするまでは上書き処理を行うと自動でこのファイルが上書きされます。便利な反面、実装を間違えると取り返しのつかないことになりますのでご注意ください。 その他の機能FileSystemAccess APIは基本は読み取り/書き込みのみですが、深掘りしていけば色々応用できそうです。ChromeのブログにはBlob型（画像や音声を取り扱える）の読み取りと書き込みをHTTPリクエストで可能にする方法も少し書いてあるので興味のある方は見てみてください。他にも上書きするファイルを再度ファイルピッカーを起動して選ぶ方法もあったりします。 おわりにこのAPIはこれまで試験的機能だったこともあってまだ枯れていない段階です。実際、ドラッグ&amp;ドロップ機能なども実装はされていますが問題も多く議論が行われている最中です。 APIの性質上セキュリティがおざなりになるとChromeの脆弱性になり得るので議論中の機能は使うべきではありませんが、今後の動向には注目していきたいです。 参考文献WICG仕様書…https://wicg.github.io/file-system-access/WebDevチームブログ…https://web.dev/file-system-access/","link":"/2020/11/22/fsaapi/"},{"title":"RSA暗号を計算する","text":"鍵交換アルゴリズムとしてはすでに脆弱性が見つかっており、めっちゃ使われているという実績のみでCRYPTRECの運用監視暗号リストにへばりついているRSA暗号なわけですが、電子署名の、特に署名検証においてはまだまだ現役です。多分。 というわけで、手軽に感動できるRSA暗号の実際の計算をやってみるとともに、最後におまけでRSAがもたらす誤解を紹介したいと思います。 データ受信者が秘密鍵を用意するまずデータ受信者は2つの互いに素な素数p,qを秘密鍵として用意します。実際の実装では1000桁ほどの大きな素数を扱うのですが、この場合は単純化してp = 5, q = 11とします。 当然秘密鍵なのでこの二つの素数は秘密にしておかなければなりません。ブラウザのJavaScriptに書くとかダメ。絶対。 データ受信者が公開鍵を用意する再びデータ受信者が2つの公開鍵を用意します。1つ目は先ほど用意した2つの秘密鍵を掛けた数値n。つまり 1n = p * q = 5 * 11 = 55 もう1つは任意の正の整数eです。実際の通信では2^16 + 1 = 65537が使われることが多いですが、今回は単純化してe = 3とします。 データ受信者が復号のための鍵を用意するまだ終わりではありません。データ受信者は今度は自分に送られてきた暗号文を復号するための鍵dを用意します。具体的な算出方法は以下の通り。 復号鍵dの求め方まず(p-1)と(q-1)の最小公倍数Lを求めます。 ユークリッドの互除法を使ってp-1, q-1の最大公約数gを求めます。今回は4と10の最大公約数なのでg = 2となります。Lはp-1とq-1の最小公倍数なので、 1L = (p - 1) * (q - 1) / g = 4 * 10 / 2 = 20 になります。 ＊今回の場合は簡単な整数なので暗算で最小公倍数を求めることができたかもしれませんが、実際の数値はもっと大きく、ユークリッドの互除法を用いて最大公約数を求めた後にそれを使って最小公倍数を求めることになります。 Lが求まったら、復号鍵dが求まります。復号鍵dの算出方法は 1d = d * e - y * L = 1 の自然解 今回の場合e = 3, L = 20なので 1d = 3d - 20y = 1 の自然解 ∴ d = 7, y = 1 となり、dが7になります。 これで鍵の用意は完了なので、いよいよ暗号と復号に入ります。 平文の暗号化今回は文字列 “RSA” を暗号化したいと思います。まずは”R”を平文mとして暗号化します。暗号化の数式は以下の通りです。 1暗号文c = m^e mod n RをUS-ASCII変換すると52なので 1c = 52^3 mod 55 = 28 この要領で”S”,”A”も暗号化すると、Sは47、Aは6になります。この時点で各バイト数を文字列に変換すると”(G ACK”になり、これが暗号文になります。いい感じに暗号っぽくなってますね。 暗号文の復号上記の方法で送信者が暗号化した文を今度は受信者が復号します。復号の数式は以下の通りです。 1平文m = C^d mod n 一文字ずつ復号してくと、 123456# \"(\"の28を復号28^7 mod 55 = 52# \"G\"の47を復号47^7 mod 55 = 53# \"ACK\"の6を復号6^7 mod 55 = 41 それぞれ文字列に変換すると”RSA”に戻ってますね。ここで確認しておきたいのが、送信者は公開鍵しか使っていないという点です。eもnも一般に公開される公開鍵ですので、送信者も使用できます。一方受信者は秘密鍵であるp,qから作成したLから作成した、実質的に秘密鍵であるdを使って復号をしています。これにより、受信者のみが復号できる暗号通信が完成します。 RSAがもたらす誤解RSAは、一つの公開鍵について秘密鍵が一つに定まる確定的暗号です(文献英語しかなかった…)。固定長のデータを一単位として暗号化するブロック暗号も確定的暗号だったりするのですが、一つの公開鍵についても動的に秘密鍵が変化する確率的暗号も存在します。しかし上述の通りRSA暗号の暗号化と復号の数式が 12c = m^e mod nm = c^d mod n と対になっているがために「暗号アルゴリズムの指数のeとdを逆にすれば署名にも使えるんじゃね？」と一般化した誤解が生まれてしまったのです。しかし、このような暗号化と復号のアルゴリズムにおける対称性があるのはRSA暗号だけであり、なおかつ近年主流になっているECDSAや、主流ですらないDSAやGOSTなど、RSA以外の電子署名暗号方式は公開鍵暗号方式をベースにしたものではありません。よって、「電子署名とは、公開鍵暗号方式の秘密鍵で暗号化することである」というのは紛れもない間違いであることは頭の片隅に置いておいてください。 こんだけイキって書いておいて頓珍漢なこと言っていたらマジで恥ずかしいですが、もし全然違う事言っていたらコメントで教えていただけるとありがたいです。 参考になれば幸いです。 参考http://blog.livedoor.jp/k_urushima/archives/1721840.htmlhttps://qiita.com/angel_p_57/items/d7ffb9ec13b4dde3357dhttps://qiita.com/shoichi0599/items/6082b765c1257b71985bhttps://medium.com/blockchain-engineer-blog/%E7%A7%81%E3%81%AF%E5%85%AC%E9%96%8B%E9%8D%B5%E6%9A%97%E5%8F%B7%E6%96%B9%E5%BC%8F%E3%81%A8%E9%9B%BB%E5%AD%90%E7%BD%B2%E5%90%8D%E3%82%92%E7%90%86%E8%A7%A3%E3%81%A7%E3%81%8D%E3%81%A6%E3%81%84%E3%81%AA%E3%81%8B%E3%81%A3%E3%81%9F%E3%82%88%E3%81%86%E3%81%A7%E3%81%99-af0894c3df0b","link":"/2020/08/18/rsa/"},{"title":"Pythonで3.14を感じてみる","text":"単に円周率を使いたいなら 12import mathprint(math.py) で良いんだけども、3.14がどうやって求まっているのか自分でやってみたい。というわけで確率的モデルで円周率を求めていきたいと思います。 第一象限の適当なところに点を打っていくまずx座標とy座標それぞれで、0から1のランダムな数値を定めて点を打ちます 12import randomx, y = random.random(), random.random() x^2+y^2が1以内かどうか確かめるこのxとyをそれぞれ2乗してお互いに足し合わせた数が1以内であれば、点は半径1の円の内側にあることになります。 1number = x ** 2 + y ** 2 #これが1以内であれば円の内側 何回も繰り返して近似値を見るこれを何回も繰り返して、繰り返した数を分母、1以内だった回数×4(全ての象限で同じ結果になると仮定する)を分子とすると、円周率が算出されます。試しに1000回くらい繰り返してみましょう。 12345678910111213141516171819import randomincount = 0def GenerateRandom(): x, y = random.random(), random.random() number = x ** 2 + y ** 2 return numberiteration = 1000for ite in range(iteration): check = GenerateRandom() if (check &lt; 1): incount += 1quadrant = 4 #全象限print(incount * quadrant / iteration) 13.2 うーん、微妙。数が少なかったようなので1000万回で試してみましょう。 12# 5秒くらいかかります3.141382 良きかな。 可視化してみる数字が出ただけだとあんまり感動しなかったのでmatplotlibで可視化してみましょう。 まずは1000回バージョン 123456789101112131415161718192021import randomimport matplotlib.pyplot as pltdef GenerateRandom(): x, y = random.random(), random.random() number = x ** 2 + y ** 2 return [number, x, y]iteration = 1000for ite in range(iteration): check = GenerateRandom() if (check[0] &lt; 1): plt.scatter(check[1], check[2], c = 'red', s = 10) else: plt.scatter(check[1], check[2], c='blue', s = 10)plt.title('Monte Carlo Method')plt.xlabel(\"x\")plt.ylabel(\"y\")plt.show() 10秒くらい待つと… イマイチ分かりにくいので1000万回バージョンをみてみましょう。 123456789101112131415161718192021import randomimport matplotlib.pyplot as pltdef GenerateRandom(): x, y = random.random(), random.random() number = x ** 2 + y ** 2 return [number, x, y]iteration = 10000000for ite in range(iteration): check = GenerateRandom() if (check[0] &lt; 1): plt.scatter(check[1], check[2], c = 'red', s = 10) else: plt.scatter(check[1], check[2], c='blue', s = 10)plt.title('Monte Carlo Method')plt.xlabel(\"x\")plt.ylabel(\"y\")plt.show() これを実行したら一旦パソコンから離れて散歩でもしましょう。帰ってきた頃には処理が終わっているはずです。 グラフを正方形にすればより分かりやすいですが、綺麗に弧を描いて分布しているのが分かります。 これを計算したからといって何か生まれるわけでもありませんが、興味を持った方は試していただけると嬉しいです。 参考情報処理学会のYouTube","link":"/2020/09/25/pypy/"},{"title":"TCPの各フェーズ概要","text":"最近ふと、「あれ？俺TCP通信理解してなくね？」と思ったので軽くTCPの働きをまとめておきます ソケットを作るアプリケーションでSocketライブラリが呼び出されたタイミングでソケット一つ分のメモリ領域を確保し、制御情報の初期値を記録する。この時点でソケットが一つできたことになるので、このソケットのディスクリプタをアプリケーションに返す。今後アプリケーションがプロトコルスタックにデータ送受信動作を依頼する際にディスクリプタを渡すことで、いちいちアプリケーションが情報を渡す手間を省くことができる。アプリケーションはこのディスクリプタと名前解決で得たサーバーのIPアドレス、IPアドレス内での接続先を示すポート番号を引数にconnect()メソッドを呼び出し、接続フェーズに入る。 サーバーと接続する宛先情報を引数として受け取ったTCPはTCPヘッダーのSYNビットを1にし、ウィンドウサイズやシーケンス番号を記載してサーバーに送信する。サーバー側のTCPは宛先のソケットに接続したらSYN・ACKビットを1にして、サーバー側のウィンドウサイズと乱数で算出したシーケンス番号を記載したTCPヘッダーをつけてクライアントに送り返す。それを受け取ったクライアントのTCPはソケットに制御情報を追加し、再びACKビットを1にしてサーバーに受信確認を送る。この接続動作ではクライアントとサーバー合わせて3回のやりとりで接続が完了するため「3ウェイ・ハンドシェイク」と呼ばれている。 データを送受信する接続が完了したらいよいよデータの送受信に入るが、TCPはMSSに近づくまで送信ようバッファメモリにデータをため、ある程度まで貯まった段階で送信動作に入る。ただ、中々MSSに近づかない場合は送信動作の遅延を招くので、一定時間が経過したら強制的に送信動作が実行される仕様になっているプロトコルスタックがほとんどである。クライアントのTCPはデータを送信する際にシーケンス番号をTCPヘッダーに記載し、サーバーのTCPは受け取ったデータのTCPヘッダーを確認してシーケンス番号＋データのバイト数であるACK番号をクライアントに返す。こうすることでクライアントはサーバーが正常にデータを受け取ったかを確認することができる。 この時、サーバーからACK番号が帰ってくるのをいちいちクライアントが待っていたら通信速度はえげつなく遅くなってしまう。そのため、実際の通信では、接続フェーズで受信側のウィンドウサイズ、つまり受信バッファの空き容量を相手に伝えて置くことでウィンドウサイズに到達するまではACK番号を待つことなくデータを送信できる仕組みになっている。受信側は受信処理が完了して新たにバッファの空き容量が変化したらTCPヘッダーのウィンドウフィールドでウィンドウサイズを通知する。 サーバーから切断するブラウザの場合はサーバーが最後のレスポンスデータを返してデータ送受信が終了するのでサーバー側から切断動作に入るが、クライアントから切断するアプリケーションも存在する。 サーバーは最後のレスポンスメッセージを送信したら、TCPヘッダーのFINビットを１にしたデータをクライアントに送信し、ソケットに切断動作に入ったという情報を記載する。FINビットが1のデータを受け取ったクライアントは同様にソケットに切断動作に入ったという情報を記載し、サーバーにACK番号を返す。その後アプリケーションにデータ受信が終了したという情報を伝え、今度はクライアントからFINビットを1にしたデータをサーバーに送信する。それを受け取ったサーバーはACK番号をクライアントに返し、切断が完了する。 あくまでこの記事はまとめなので実際にデータ送受信の際はもっと他の動作も行われていますが、接続から切断までクライアントとサーバーのTCPさんが行っている仕事を大まかに説明するとこんな感じになります。 もし「こいつ何言ってんだ」と思う部分があれば、ぜひコメントで教えていただけるとありがたいです。","link":"/2020/08/09/tcp/"},{"title":"Eslint&amp;Prettierとhuskyで幸せになろう！","text":"PrettierやEslintを毎度毎度コマンドから動かしてフォーマットするのもかったるいので、huskyでコミット時に自動整形してくれるように設定したいと思います。eslintrc等はnpmモジュール用の設定で進めるのでご了承ください。 開発環境パッケージ管理 : npm OS : Mac OS 言語 : Node.js Eslintをインストールする1yarn add eslint Eslint init1./node_modules/eslint/bin/eslint.js --init ここで色々質問されるので、お好みで答えていきましょう。各質問の詳細はこちらの記事がおすすめ Prettierをインストールする1yarn add prettier eslint-config-prettier eslint-plugin-prettier -D eslintrc.jsの設定先ほどのeslint initで自動的に生成された.eslintrc.js(.eslint.json,.eslint.ymlnの場合もある)をPrettier用に設定します 12345678910111213141516171819202122232425262728293031323334module.exports = { env: { commonjs: true,//requireを有効にする es6: true,//importを有効にする es2020: true,//最新のEcmaScriptを有効にする node: true,//Webアプリなどブラウザで使用するコードの場合はbrowser:true mocha: true,//テストでmochaを使う場合は追記しないとエラーが出る }, extends: ['eslint:recommended', 'plugin:prettier/recommended'],//eslintとprettier両方を追加 parserOptions: { ecmaVersion: 11, }, rules: { //eslintの設定 indent: ['error', 2],//インデントはスペース2個分 quotes: ['error', 'single'],//文字列はシングルクオート semi: ['error', 'always'],//セミコロンを必須に 'linebreak-style': ['error', 'unix'],//改行スタイルをunixに 'no-var': 'error',//varを使ったらエラー 'prefer-const': 'error',//再代入のないconstはエラー 'prefer-arrow-callback': 'error',//アロー関数でコールバック関数を書く //prettierの設定 'prettier/prettier': [ 'error', { useTabs: false,//インデントはタブではなくスペース singleQuote: true,//文字列はシングルクオート semi: true,//セミコロン必須 tabWidth: 2,//インデントはスペース2個分 printWidth: 120,//一行は120文字まで }, ], },}; 注意点としては、prettierとeslintでルールが競合してしまうとエラーが止まらなくなってしまうので必ずルールは矛盾させないこと。 huskyとlint-stagedインストール1yarn add husky lint-staged -D でも良い husky,lint-stagedの初期設定1npx mrm lint-staged package.jsonの設定12345678910111213141516171819\"lint-staged\": { \"*.js\": [ \"prettier '**/*.{js,jsx,ts,tsx,vue}' --write\",//js,jsx,ts,tsx,vueファイルを整形 \"eslint --fix\"//eslintで全部整形(.eslintignoreを設定すれば対象外のファイルを指定できる) ]},\"husky\": { \"hooks\": { \"pre-commit\": \"lint-staged\"//commit時にlint-stagedを実行 }},//prettierの設定\"prettier\": { \"useTabs\": false, \"singleQuote\": true, \"semi\": true, \"tabWidth\": 2, \"printWidth\": 120}, もしこれでうまく動かないことがあれば、コメント欄で教えていただけると嬉しいです。 参考文献https://stackoverflow.com/questions/50048717/lint-staged-not-running-on-precommithttps://qiita.com/berry99/items/d1ca66b477f48856256d","link":"/2020/08/15/ephusky/"}],"tags":[{"name":"encryption","slug":"encryption","link":"/tags/encryption/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"english","slug":"english","link":"/tags/english/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"selenium","slug":"selenium","link":"/tags/selenium/"},{"name":"scraping","slug":"scraping","link":"/tags/scraping/"},{"name":"googleform","slug":"googleform","link":"/tags/googleform/"},{"name":"aws","slug":"aws","link":"/tags/aws/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"api","slug":"api","link":"/tags/api/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"matplotlib","slug":"matplotlib","link":"/tags/matplotlib/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"tcp","slug":"tcp","link":"/tags/tcp/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"eslint","slug":"eslint","link":"/tags/eslint/"},{"name":"prettier","slug":"prettier","link":"/tags/prettier/"},{"name":"husky","slug":"husky","link":"/tags/husky/"},{"name":"pre-commit","slug":"pre-commit","link":"/tags/pre-commit/"}],"categories":[{"name":"英語","slug":"英語","link":"/categories/%E8%8B%B1%E8%AA%9E/"},{"name":"コーディング","slug":"コーディング","link":"/categories/%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0/"},{"name":"暗号","slug":"暗号","link":"/categories/%E6%9A%97%E5%8F%B7/"},{"name":"ネットワーク","slug":"ネットワーク","link":"/categories/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF/"}]}