{"pages":[],"posts":[{"title":"Encoding, Encryption, Hashing, Obfuscationの意味","text":"ある日ネットサーフィンをしていたらEncoding vs. Encryption vs. Hashing vs. Obfuscationという記事を見つけた。この四つの単語はそれぞれ実際には全く違う意味なんだけど「違いを説明せよ」と突然言われたら確かに説明できないなぁ、と思ったので元記事の内容に沿って各単語の意味を整理しておきます。 各単語の概要Encodingデータをある一定の規則に基づいて可逆な別のデータに変換すること。和訳は符号化。 Encryptionデータをアルゴリズムを使って特定の「鍵」によって復号可能な別のデータに変換すること。和訳は暗号化。 Hashingデータをアルゴリズムを使って非可逆な別のデータに変換すること。和訳はハッシング。 Obfuscationデータの意味は変えないまま人間にとって読みにくい別のデータに変換すること。和訳は難読化。 Encoding 和訳 : 符号化 可逆 符号化は比較的幅広い分野で当てはまる概念である。脳科学においても符号化（記銘）という概念があり、言語の翻訳もある意味では符号化である。またカメラの画像処理やアナログ音声のA/D変換においても符号化の概念が利用されている。挙げていくとキリがなくてただでさえ短い夏休みが無駄になってしまうので全て調べ上げることはできないが、要するに、「あるデータを誰かにとって理解しやすいデータに規則正しく変換する」というのが符号化の意味である。この概念を応用した例としてはデータの圧縮なども挙げられる。 情報科学であればコンピュータ、脳科学であれば脳、言語学であればその国の人にとって理解しやすいデータの形を作ってあげるのが、符号化の仕事であり、概念である。この記事を見ているであろう技術者の方に馴染みのある例をあげればUnicodeやBase64、ASCIIなどが符号化データに当たる。&nbsp;&nbsp;上記で述べた概念を用いれば、DNSサーバーでURLをIPアドレスに変換する処理も、通信プロトコルが理解しやすいデータに変換するという意味では符号化に当てはまる。実際の通信では2進数でやりとりされるIPアドレスを人間様の読みやすいように10進数に変換する処理もまた、符号化である。 Encryption 和訳 : 暗号化 可逆 暗号化は主に情報通信において使われることが多い。暗号の起源として知られるものとして ヒエログリフ(象形文字)が挙げられるが、ヒエログリフそのものに秘匿性の意図はなく、単に後世で解読にえげつなく時間がかかったというだけなので厳密には暗号ではないとされている。古代から近代にかけては主に軍事的な目的で暗号が発明されることが多く、有名なシーザー暗号やドイツ軍のエニグマの暗号方式などもその一つである。古代の暗号から共通する目的として、データを秘密に保つことが挙げられる。これに関しては直感的に分かりやすいので詳しく説明する必要はないが、カッコよく言えば「秘匿性」である。&nbsp;&nbsp;現代の情報通信における暗号化では、一つの通信で使われる暗号アルゴリズムなどを、暗号スイートという文字列で表す。例えば、 1ECDHE-RSA-AES128-GCM-SHA256 という暗号スイートがあった場合、鍵交換にはECDHE、鍵認証にはRSA、暗号化アルゴリズムにはAES128、暗号モードはGCM、ハッシュ関数にはSHA-256が使われているということを示す。 ＊鍵認証と暗号化アルゴリズムの間に「_WITH_」が入る場合もある Hashing 和訳 : ハッシング 非可逆 ハッシングは主に情報通信で使われ、アルゴリズムに基づいてあるデータを一見乱数に見える解読不可能で非可逆な別のデータに変換することをいう。暗号化と違って秘匿性の目的はなく、主に検索の高速化や改竄検知に使われる。&nbsp;&nbsp;例えば、ハッシュ探索アルゴリズムは一般的な線形探索アルゴリズムに比べて高速な処理が期待でき、ハッシュを利用したLandmark-based fingerprintingはShazamの音声類似性検索のアルゴリズムにも採用されている。改竄検知でいえば、最も有名なのがSHA-1, SHA-2ハッシュ関数である。改竄検知の方法としてはデータをハッシュ化して暗号化したデータと共に送信し、受信側がデータを復号してハッシュ化した際に元のハッシュ値と違った場合に改竄が検出されるというものである。SHA-1に関しては2005年から脆弱性が指摘され、2017年にGoogleが実際に攻撃に成功したことが決定的となって利用は大幅に減少した。2020年7月にIPAから公開されたCRYPTRECの利用禁止暗号アルゴリズムにもノミネートされている。 Obfascation 和訳 : 難読化 可逆 難読化とは、主にソースコードの解析防止や知的財産権の保護を目的として敢えて読みにくいコードに変換することである。概念を説明すれば「誰かにとって扱いにくいデータに変換する」、つまり概念的には符号化の対極に位置するものとも言える。難読化がソースコードの文脈以外で使われている例はぶっちゃけ思いつかないし、ググっても出てこないので「難読化=ソースコードの難読化」と考えて良いだろう。&nbsp;&nbsp;ソースコードを難読化する理由としては、上述のように、実装している独自アルゴリズムのパクリや機能制限の回避を目的としたリバースエンジニアリングを防ぐ目的がほとんどである。実際JavaScriptやPythonなど、主要なスクリプト言語ほぼ全てに難読化パッケージ/ツールがあるが、手作業でやるのは単純に初心者がコードを書くのと一緒になってしまうので完全に時間の無駄である。 ＊筆者の場合は自分が書くコードは無意識に難読化されているので難読化ツールは特に必要ない。&nbsp;&nbsp;ここからは筆者の個人的な意見だが、個人プロジェクト以外のコードはほぼ確実に他人と共有する必要があり、その時に難読化されたコードをレビューしろとか改変しろとか言われたらたまったもんじゃない。なので本当に隠したい処理はサーバーサイドで書き、どうしてもクライアントサイドで書かなければならない場合は開発が終了して保守のフェーズに入る際に難読化することをお勧めする。 といった感じでできるだけ各単語の概念を踏まえて整理したので、参考にしていただけるとありがたいです。&nbsp;&nbsp;「ここ違うぜ」と思った方はコメントで教えていただけると非常に勉強になるので嬉しいです。 参考文献https://www.netagent.co.jp/study/blog/hard/20180726.html https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/ https://www.geeksforgeeks.org/encryption-encoding-hashing/ https://www.packetlabs.net/encryption-encoding-and-hashing/","link":"/2020/08/10/enword/"},{"title":"Eslint&amp;Prettierとhuskyで幸せになろう！","text":"PrettierやEslintを毎度毎度コマンドから動かしてフォーマットするのもかったるいので、huskyでコミット時に自動整形してくれるように設定したいと思います。eslintrc等はnpmモジュール用の設定で進めるのでご了承ください。 開発環境パッケージ管理 : npm OS : Mac OS 言語 : Node.js Eslintをインストールする1$ npm install eslint Eslint init1$ ./node_modules/eslint/bin/eslint.js --init ここで色々質問されるので、お好みで答えていきましょう。各質問の詳細はこちらの記事がおすすめ Prettierをインストールする1npm install prettier eslint-config-prettier eslint-plugin-prettier --save-dev eslintrc.jsの設定先ほどのeslint initで自動的に生成された.eslintrc.js(.eslint.json,.eslint.ymlnの場合もある)をPrettier用に設定します 12345678910111213141516171819202122232425262728293031323334module.exports = { env: { commonjs: true,//requireを有効にする es6: true,//importを有効にする es2020: true,//最新のEcmaScriptを有効にする node: true,//Webアプリなどブラウザで使用するコードの場合はbrowser:true mocha: true,//テストでmochaを使う場合は追記しないとエラーが出る }, extends: ['eslint:recommended', 'plugin:prettier/recommended'],//eslintとprettier両方を追加 parserOptions: { ecmaVersion: 11, }, rules: { //eslintの設定 indent: ['error', 2],//インデントはスペース2個分 quotes: ['error', 'single'],//文字列はシングルクオート semi: ['error', 'always'],//セミコロンを必須に 'linebreak-style': ['error', 'unix'],//改行スタイルをunixに 'no-var': 'error',//varを使ったらエラー 'prefer-const': 'error',//再代入のないconstはエラー 'prefer-arrow-callback': 'error',//アロー関数でコールバック関数を書く //prettierの設定 'prettier/prettier': [ 'error', { useTabs: false,//インデントはタブではなくスペース singleQuote: true,//文字列はシングルクオート semi: true,//セミコロン必須 tabWidth: 2,//インデントはスペース2個分 printWidth: 120,//一行は120文字まで }, ], },}; 注意点としては、prettierとeslintでルールが競合してしまうとエラーが止まらなくなってしまうので必ずルールは矛盾させないこと。 huskyインストール1$ npm install husky --save-dev lint-stagedインストール1$ npm install lint-staged --save-dev ぶっちゃけまとめて 1npm install husky lint-staged --save-dev でも良い husky,lint-stagedの初期設定1npx mrm lint-staged package.jsonの設定12345678910111213141516171819\"lint-staged\": { \"*.js\": [ \"prettier '**/*.{js,jsx,ts,tsx,vue}' --write\",//js,jsx,ts,tsx,vueファイルを整形 \"eslint --fix\"//eslintで全部整形(.eslintignoreを設定すれば対象外のファイルを指定できる) ]},\"husky\": { \"hooks\": { \"pre-commit\": \"lint-staged\"//commit時にlint-stagedを実行 }},//prettierの設定\"prettier\": { \"useTabs\": false, \"singleQuote\": true, \"semi\": true, \"tabWidth\": 2, \"printWidth\": 120}, もしこれでうまく動かないことがあれば、コメント欄で教えていただけると嬉しいです。 参考文献https://stackoverflow.com/questions/50048717/lint-staged-not-running-on-precommithttps://qiita.com/berry99/items/d1ca66b477f48856256d","link":"/2020/08/15/ephusky/"},{"title":"毎朝5時にGoogle Formに自動回答したい","text":"みなさんこんにちは。夏ですね。僕もついに部活動が再開し、ワクワクドキドキな訳ですが、一昨日の夜顧問からこんな連絡がきました。 12- 毎朝5時20分までに検温を行い、結果をGoogleFormから報告してください- 報告がなかった部員は朝練の参加を認めません そもそも朝練が6時半から始まる時点でイッているので5時20分に連絡しろと言われてもさほど驚かなかったのですが、ここで一つ問題が発生しました。 というのも僕は普段朝5時に起き、そのままパンをかじりながら自転車で駅に向かうので、検温をする時間がないのです。もう少し早起きすれば済む話なのですが、4時起きは流石にきついし体がもたないのでやりたくない。かといって5時に起きて検温なんかしていたら朝練そのものに遅れてしまう。 というわけで、朝5時くらいに、心配されない程度の体温をよしなに指定のFormに入力して送信してくれるプログラムを作りたいと思います。 Seleniumでフォームを送信する本物のフォームを使ってやると僕の身元がバレてしまうので、今回はテスト用に僕が作成した本物と同じ内容のフォームで実装したいと思います。 初期値入力つきURLを用意するGoogle Formは、パラメータをつけることで各質問の値を入力した状態でURLを開くことができます。普通にフォームを開く際のURLは https://docs.google.com/forms/d/e/1FAIpQLScGgZ8dsBkcSVutvW3JgDLqy3pIEKk12ucjiA8mNQrKopILog/viewform?usp=sf_link こんな感じでviewformの後に「usp=sf_link」というパラメータがついています。このパラメータは事前入力のない、ピュアな回答フォームであることを示しているので、まずここを「usp=pp_url」に変えて、事前入力があることを知らせてあげます。&nbsp;&nbsp;そしたら次に各質問の回答をパラメータに入力していきます。フォームの各質問を識別する番号があるので、Chromeの検証画面で質問のdivを探し、2階層目で以下のような番号を探します。番号を見つけたらentry.番号=回答内容の形でパラメータを加えます。今回は名前と体温をテキストで入力するので以下のようなURLになります。 https://docs.google.com/forms/d/e/1FAIpQLScGgZ8dsBkcSVutvW3JgDLqy3pIEKk12ucjiA8mNQrKopILog/viewform?usp=pp_url&amp;entry.1534939278=荒川智則&amp;entry.511939456=36.5しかしこのままだと毎日36.5度を報告することになり、流石に怪しまれるので、乱数で良い感じに値を振ります。 1234# 36.1~36.7の間でランダムに値を生成して文字列変換body_temp = str(36 + random.randint(1,7)/10)# URLの最後に加えるurl = 'https://docs.google.com/forms/d/e/1FAIpQLScGgZ8dsBkcSVutvW3JgDLqy3pIEKk12ucjiA8mNQrKopILog/viewform?usp=pp_url&amp;entry.1534939278=荒川智則&amp;entry.511939456='+body_temp Seleniumで自動提出URLが完成したら、あとはSeleniumでURLを開き、ポチッと提出ボタンを押してもらうだけです。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# SeleniumとChromedriverをpipでインストールしておくfrom selenium import webdriverimport chromedriver_binaryimport timeimport randombody_temp = str(36 + random.randint(1,7)/10)url = 'https://docs.google.com/forms/d/e/1FAIpQLScGgZ8dsBkcSVutvW3JgDLqy3pIEKk12ucjiA8mNQrKopILog/viewform?usp=pp_url&amp;entry.1534939278=荒川智則&amp;entry.511939456='+body_temp# クリックの関数def click(xpath): driver.find_element_by_xpath(xpath).click()# パスワード入力の関数def insert_pw(xpath, str): driver.find_element_by_xpath(xpath).send_keys(str)driver = webdriver.Chrome()driver.implicitly_wait(1)driver.get(url)moving_login_button = '/html/body/div[2]/div/div[2]/div[3]/div[2]'time.sleep(1)# Googleアカウントでのログインが必要な場合はログインするif(driver.find_elements_by_xpath(moving_login_button) != []): click(moving_login_button) login_id = \"{Googleアカウントのメアド}\" login_id_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[1]/div/form/span/section/div/div/div[1]/div/div[1]/div/div[1]/input' login_id_button = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[2]/div/div[1]/div/div' insert_pw(login_id_xpath, login_id) click(login_id_button) time.sleep(1) login_pw = \"{Googleアカウントのパスワード}\" login_pw_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[1]/div/form/span/section/div/div/div[1]/div[1]/div/div/div/div/div[1]/div/div[1]/input' login_pw_button = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[2]/div/div[1]/div/div' insert_pw(login_pw_xpath, login_pw) time.sleep(1) click(login_pw_button)time.sleep(1)submit_button = '//*[@id=\"mG61Hd\"]/div[2]/div/div[3]/div[1]/div/div'click(submit_button)print(\"Done!\")driver.close# メモリーを食うのでちゃんと終了しましょうdriver.quit しっかり送信できました。 定期イベントにするコードが書けたらあとは定期イベント化するだけなのですが、ここで少しつまづいたのでやり方を説明しておきます。&nbsp;&nbsp;当初予定していた方法としてはAutomatorでアプリ化し、カレンダーに入れて毎日実行する方法(参考)。これなら報告しなくて良い日はカレンダーから外せば良いし、完璧なはず。と思ったのですが、PCをシャットダウンしていると動作しないためボツ。crontabに設定して定期イベント化する方法も同様の理由でボツ。 結局臨機応変にイベントの変更はできないものの、PCの状態にかかわらず実行してくれるAWSのLambdaを使用することに決めました。(Lambdaの使い方はこのサイトとかが参考になりました) LambdaのレイヤーにSeleniumとChromedriver、headless-chromiumを上げるLambdaでライブラリを使うには各フォルダをzipに圧縮してレイヤーにアップロードする必要があります。今回はSeleniumとChromeのWebdriverであるChromedriver、それからChromeを開かずにスクレイピングを行うためのheadless-chromiumを使用するので、それぞれzipに圧縮してレイヤーに上げていきます。 1. Selenium1234567mkdir seleniumcd seleniummkdir pythoncd pythonpip install selenium -t .cd ../zip -r selenium.zip ./python できたzipファイルをそのままレイヤーにアップロードします。 2. Chromedriverとheadless-chromium12curl https://github.com/adieuadieu/serverless-chrome/releases/download/v1.0.0-55/stable-headless-chromium-amazonlinux-2017-03.zip &gt; headless-chromium.zipcurl https://chromedriver.storage.googleapis.com/2.43/chromedriver_linux64.zip &gt; chromedriver.zip できた二つのzipファイルを解凍し、headless-chromeフォルダにまとめます。その後そのheadless-chromeをzipに圧縮してレイヤーにアップロードします。 3. レイヤーを関数に適用関数の下にある「Layers」を押し、下の「レイヤーの追加」ボタンから二つのレイヤを追加します ※注意※ Lambda関数のランタイムをPython3.8にするとChromedriverが動いてくれなかった(原因不明)ので、ランタイムはPython3.6か3.7に設定することをお勧めします。 headless-chromiumとChromedriverの間に互換性がないと動作しないのでこちらから最新版を入手しても動作しない可能性があります。 Lambda用にコードを少し変える筆者は今までCloud9以外のAWSツールを使ったことがないへっぽこコーダーなので、色んなサイトの見様見真似でなんとかLambdaで動くコードにしました。先人に感謝。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import jsonfrom selenium import webdriverimport timeimport randomdef lambda_handler(event, context): body_temp = str(36 + random.randint(1,7)/10) url = 'https://docs.google.com/forms/d/e/1FAIpQLScGgZ8dsBkcSVutvW3JgDLqy3pIEKk12ucjiA8mNQrKopILog/viewform?usp=pp_url&amp;entry.1534939278=荒川智則&amp;entry.511939456='+body_temp options = webdriver.ChromeOptions() options.binary_location = '/opt/headless-chrome/headless-chromium' # このオプション4つを付けないとChromeは起動せずエラーになります options.add_argument('--headless') # サーバーレスでChromeを起動 options.add_argument('--no-sandbox') # sandbox外でChromeを起動 options.add_argument('--single-process') # タブ/サイトごとのマルチプロセスではなく、シングルプロセスへ切り替える options.add_argument('--disable-dev-shm-usage') # メモリファイルの出力場所を変える driver = webdriver.Chrome('/opt/headless-chrome/chromedriver',options = options) driver.implicitly_wait(1) driver.get(url) def click(xpath): driver.find_element_by_xpath(xpath).click() def insert_pw(xpath, str): driver.find_element_by_xpath(xpath).send_keys(str) moving_login_button = '/html/body/div[2]/div/div[2]/div[3]/div[2]' time.sleep(2) if(driver.find_elements_by_xpath(moving_login_button) != []): click(moving_login_button) # 環境変数でMY_GMAILにGoogleアカウントのメアドを設定してください login_id = MY_GMAIL login_id_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[1]/div/form/span/section/div/div/div[1]/div/div[1]/div/div[1]/input' login_id_button = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[2]/div/div[1]/div/div' insert_pw(login_id_xpath, login_id) click(login_id_button) time.sleep(1) # 環境変数でMY_PASSWORDにGoogleアカウントのパスワードを設定してください login_pw = MY_PASSWORD login_pw_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[1]/div/form/span/section/div/div/div[1]/div[1]/div/div/div/div/div[1]/div/div[1]/input' login_pw_button = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[2]/div/div[1]/div/div' insert_pw(login_pw_xpath, login_pw) time.sleep(1) click(login_pw_button) time.sleep(1) submit_button = '//*[@id=\"mG61Hd\"]/div[2]/div/div[3]/div[1]/div/div' click(submit_button) driver.close driver.quit return { 'statusCode': 200, 'body': json.dumps('Form submission success!!') } 注意点 Chromeの起動オプション--headless,--no-sandbox,single-process,--disable-dev-shm-usageを付けないとLambda上で正常に起動せず、エラーが出ます。各オプションについての詳細はこちらをご覧ください レイヤーにアップロードしたファイルはoptディレクトリの配下に置かれます。パスを指定する際はopt/ディレクトリ名/…の形で表記しましょう CloudWatch Eventsでトリガーを設定 関数の「Layers」をクリックして「トリガーを追加をクリック」し、ドロップダウンから「EventBridge (CloudWatch Events)」を選択します。 ルールは「新規ルールの作成」で任意のルール名を入力。ルールタイプをスケジュール式にし、今回は毎日朝5時なのでcorn(0 20 ? * * *)と入力(LambdaはUTCでトリガーされるので9時間前をセットすることに留意)。トリガーを有効にして「追加」をクリックします。（cronの書き方はこちらをご覧ください） テスト最後にしっかり動くかテストしましょう。Lambda関数画面の「テスト」をクリックします。大丈夫そうですね。 おわりに朝の検温はサボっていますが、寝る前にちゃんと測っているので安心してください。 参考文献https://masakimisawa.com/selenium_headless-chrome_python_on_lambda/https://github.com/heroku/heroku-buildpack-google-chrome/issues/56https://qiita.com/mishimay/items/afd7f247f101fbe25f30","link":"/2020/08/11/gfa/"},{"title":"TCP通信におけるTCPプロトコルの動き","text":"最近ふと、「あれ？俺TCP通信理解してなくね？」と思ったので軽くTCPの働きをまとめておきます ソケットを作るアプリケーションでSocketライブラリが呼び出されたタイミングでソケット一つ分のメモリ領域を確保し、制御情報の初期値を記録する。この時点でソケットが一つできたことになるので、このソケットのディスクリプタをアプリケーションに返す。今後アプリケーションがプロトコルスタックにデータ送受信動作を依頼する際にディスクリプタを渡すことで、いちいちアプリケーションが情報を渡す手間を省くことができる。アプリケーションはこのディスクリプタと名前解決で得たサーバーのIPアドレス、IPアドレス内での接続先を示すポート番号を引数にconnect()メソッドを呼び出し、接続フェーズに入る。 サーバーと接続する宛先情報を引数として受け取ったTCPはTCPヘッダーのSYNビットを1にし、ウィンドウサイズやシーケンス番号を記載してサーバーに送信する。サーバー側のTCPは宛先のソケットに接続したらSYN・ACKビットを1にして、サーバー側のウィンドウサイズと乱数で算出したシーケンス番号を記載したTCPヘッダーをつけてクライアントに送り返す。それを受け取ったクライアントのTCPはソケットに制御情報を追加し、再びACKビットを1にしてサーバーに受信確認を送る。この接続動作ではクライアントとサーバー合わせて3回のやりとりで接続が完了するため「3ウェイ・ハンドシェイク」と呼ばれている。 データを送受信する接続が完了したらいよいよデータの送受信に入るが、TCPはMSSに近づくまで送信ようバッファメモリにデータをため、ある程度まで貯まった段階で送信動作に入る。ただ、中々MSSに近づかない場合は送信動作の遅延を招くので、一定時間が経過したら強制的に送信動作が実行される仕様になっているプロトコルスタックがほとんどである。クライアントのTCPはデータを送信する際にシーケンス番号をTCPヘッダーに記載し、サーバーのTCPは受け取ったデータのTCPヘッダーを確認してシーケンス番号＋データのバイト数であるACK番号をクライアントに返す。こうすることでクライアントはサーバーが正常にデータを受け取ったかを確認することができる。 この時、サーバーからACK番号が帰ってくるのをいちいちクライアントが待っていたら通信速度はえげつなく遅くなってしまう。そのため、実際の通信では、接続フェーズで受信側のウィンドウサイズ、つまり受信バッファの空き容量を相手に伝えて置くことでウィンドウサイズに到達するまではACK番号を待つことなくデータを送信できる仕組みになっている。受信側は受信処理が完了して新たにバッファの空き容量が変化したらTCPヘッダーのウィンドウフィールドでウィンドウサイズを通知する。 サーバーから切断するブラウザの場合はサーバーが最後のレスポンスデータを返してデータ送受信が終了するのでサーバー側から切断動作に入るが、クライアントから切断するアプリケーションも存在する。 サーバーは最後のレスポンスメッセージを送信したら、TCPヘッダーのFINビットを１にしたデータをクライアントに送信し、ソケットに切断動作に入ったという情報を記載する。FINビットが1のデータを受け取ったクライアントは同様にソケットに切断動作に入ったという情報を記載し、サーバーにACK番号を返す。その後アプリケーションにデータ受信が終了したという情報を伝え、今度はクライアントからFINビットを1にしたデータをサーバーに送信する。それを受け取ったサーバーはACK番号をクライアントに返し、切断が完了する。 あくまでこの記事はまとめなので実際にデータ送受信の際はもっと他の動作も行われていますが、接続から切断までクライアントとサーバーのTCPさんが行っている仕事を大まかに説明するとこんな感じになります。 もし「こいつ何言ってんだ」と思う部分があれば、ぜひコメントで教えていただけるとありがたいです。","link":"/2020/08/09/tcp/"}],"tags":[{"name":"encryption","slug":"encryption","link":"/tags/encryption/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"english","slug":"english","link":"/tags/english/"},{"name":"eslint","slug":"eslint","link":"/tags/eslint/"},{"name":"prettier","slug":"prettier","link":"/tags/prettier/"},{"name":"husky","slug":"husky","link":"/tags/husky/"},{"name":"pre-commit","slug":"pre-commit","link":"/tags/pre-commit/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"selenium","slug":"selenium","link":"/tags/selenium/"},{"name":"scraping","slug":"scraping","link":"/tags/scraping/"},{"name":"googleform","slug":"googleform","link":"/tags/googleform/"},{"name":"aws","slug":"aws","link":"/tags/aws/"},{"name":"tcp","slug":"tcp","link":"/tags/tcp/"},{"name":"network","slug":"network","link":"/tags/network/"}],"categories":[{"name":"英語","slug":"英語","link":"/categories/%E8%8B%B1%E8%AA%9E/"},{"name":"コーディング","slug":"コーディング","link":"/categories/%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0/"},{"name":"自動化","slug":"自動化","link":"/categories/%E8%87%AA%E5%8B%95%E5%8C%96/"},{"name":"ネットワーク","slug":"ネットワーク","link":"/categories/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF/"}]}