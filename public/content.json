{"pages":[],"posts":[{"title":"be bound toって「必ず〜する」じゃないんかい","text":"SSIの研究を始めて、まだ下調べの段階なので仕様書を頑張って読んでいたのだが、ちょっと論文でも読んでみようかなという出来心でGoogle Scholorで上の方にあったSSIの論文を読むことにした。 https://arxiv.org/abs/1712.01767 全然進まないんですけど当然英語なので和訳しつつ内容を把握していく感じなのだが、とにかく時間がかかる。論文自体は1段組み5ページでそこまで長くなく、数式もないので理解はしやすいはずなのだが、何せ論文を真面目に読み込んだことのないクソコーダーなのでAbstractを読むだけでびっくりするくらい時間がかかる。なかなか論文の著者が伝えたいことを理解できないまま3ページくらいまで進んだ時、SSIのワークショップがコンセプトを策定した文脈で Identities are bound to single transactions and formed with one-way functions from the core identity という文章が出てきた。「はいはい知ってまっせ、be bound toだから『必ず〜する』でしょ」と流して読もうとしたのだが、この熟語の後がsingle transactionで名詞なのでこれだと意味が通らない。日本語でググっても出てこないので「もしや単純にbindの受動態では？」と思って文章を見直してみたら普通に意味通ってた。一生の不覚。 ちなみにbindは「縛る」「拘束する」という意味でコーダー的には「関連づける」「結びつける」という意味で理解していて、熟語のbe bound toも「未来が縛られている」=&gt;「必ず〜する」という解釈をすればなんとなく意味が通じる。気がする。 上の文章は「アイデンティティは取引一つ一つと関連づけられ、なおかつコア・アイデンティティからの一方向性関数で構成される」という和訳になる。コア・アイデンティティというのは人間の生物的な特徴：指紋や顔認識データと名前などの識別情報からなる情報群のこと（詳細は論文を読んでもろて）。一方向性関数というのは、RSA暗号で用いられる素因数分解の困難性に代表される、簡単に計算できるが逆関数の計算はめちゃくちゃ難しく時間がかかる関数のことを指す。量子コンピューターが普及したら通用しなくなるかもしれないやつ、という認識で良い。 おわりに多分英語が強い人からしたらどこにも疑問を感じる点はないんだろうな、と思いつつ、熟語を暗記していたばかりにこんな恥ずかしい思いをしたのでちゃんと単語の意味から理解しないとなと思う八谷でした。ではまた。","link":"/2020/12/23/bound/"},{"title":"【論文和訳】Self-sovereign Identity - Opportunities and Challenges for the Digital Revolution","text":"訳者によるまえがき今回和訳する論文は2017年のSSIに関する論文Self-sovereign Identity − Opportunities and Challenges for the Digital Revolutionである。 なお、原文内で「Self-sovereign degital identity」と書かれている部分は「自己主権型デジタルアイデンティティ」と訳し、「Self-sovereign Identity」と書かれている部分は「SSI」と訳している。 訳文要約（Abstract）人とサービス、端末の相互接続性はデジタル革命における一つの決定的な側面であり、安全なデジタルアイデンティティは合法的に情報交換をするための前提条件である。 現状、このセキュアなアイデンティティ管理を提供しているのは中央集権的なIDプロバイダ、例えば国家機関やオンラインサービスのプロバイダに限られている。そのため、データをプロバイダ間で移行する手順はなく、新しいサービスに移行する、もしくは居住地を変更する場合は新たにIDを作らなければならない。 自己主権型デジタルアイデンティティは今までと違い、個人によるアイデンティティの作成・管理とサービスプロバイダや国のeIDインフラから独立したデジタルアイデンティティの維持を可能にする。 目次（Table of Contents） 障壁のないデジタルアイデンティティ（Digital Identities without Barriers） 個人のための自己主権型デジタルアイデンティティ（Self-sovereign Digital Identities for Persons） ISÆN: 人類のためのSSI標準化（Standardizing Self-sovereign Identities for Human Beings） Outlook: 物、組織のためのSSI（Self-sovereign Identities for Things and Institutions） 1. 障壁のないデジタルアイデンティティデジタルアイデンティティはヨーロッパだけでなく世界中で日常生活の一部になっている。ネット上のサービスでは、従来はユーザー名とパスワードで十分だったが、チップやセキュリティトークン、eIDなど特殊なソフト・ハードウェアによるユーザーの安全な識別が求められている。人間の識別に加えて、人間でないもの: 企業やデバイスなどの認識も、情報交換において重要になり、データや情報のソースの検証も重要になっている。IoTやConnected Carなどの経済発展には、信頼に値するシステムや人間の識別が鍵である。 各デジタルアイデンティティは、アイデンティティの断片から構成され、通常は特定のサービスへのアクセスや別のエンティティとのデータ・情報交換など、特定の目的のもと作成される。それぞれのデジタルアイデンティティにおいて、記述の正確さや抽象化の度合いなどの情報の詳細さは異なる。加えて、デジタルアイデンティティは明確な時間軸を持ち、ある程度の変更は許容される必要がある（住所や口座情報、身長や最終学歴など）。つまりあるエンティティに対してのアイデンティティは一つだが、デジタルアイデンティティは複数存在しえる。人間の場合はこのデジタルアイデンティティが瞬く間に膨大な数に達する。 「セキュアなデジタルアイデンティティ」という言葉はプライバシーと信頼性の条件をまとめたものである。プライバシーとは、認証された人、組織、システムのみがデジタルアイデンティティにアクセスできること、その許可はデジタルアイデンティティに記述されているエンティティによって与えられることを意味する。信頼性とは、デジタルアイデンティティを含む情報の正確性、つまり情報が実際に一定の保証を受けたエンティティに属することを表す。 以下の3つの例は世界規模で安全なデジタルアイデンティティとは何なのかを説明する例である。 官民パートナーシップ「ID2020」は全ての人類に個人的・永続的・プライベートでポータブルなデジタルアイデンティティを提供することを目的としている。この取り組みは特に、これまでこういったアイデンティティを得られなかった1億人以上の人々を特に重要視しており、2030年までに全ての人に合法的なアイデンティティを付与することを目的とした「国連持続可能な開発計画」を踏襲している。 2015年時点で、2億4400万人以上が、生まれた国とは別の国に暮らしている。理由はそれぞれ異なるが、ID管理の要件は、「以前の」ID（本来アイデンティティは単一であるべきであり、「以前の」IDなどあってはならないのである）へのアクセスを保持していなければならないという点においてどのケースでも同様である。前の居住地で収集された健康データは更なる治療計画に必要であり、資格証明書は新たな居住地における雇用の前提条件である。この問題は海外留学の途中である学生や、複数の居住地を持つ人にも当てはまる。 EUはヨーロッパのデジタル統一市場を強化することに注力している。越境可能なデジタルアイデンティティは、EU加盟国間の経済的、組織的な壁を取り除き、個人や企業がよりアグレッシブにヨーロッパ内の市場で経済活動できるようにすることを目的としたeIDAS規則や一般データ保護規制（以下GDPR）と並んで成功の鍵である。 上記の例は人間のデジタルアイデンティティに関するものだが、現在のIoTなどの発展は、これが人間でないエンティティ、企業やデバイス、車などにも当てはまることを示している。相互接続されたデバイスの高度な分散型アーキテクチャーは、稼働場所に関わらない安全なデジタルアイデンティティが条件となる。 これは国家的、地理的に制限されたアイデンティティ管理手法の限界を指摘している。一般的に、この問題を解決する方法は2つ、管理主体のグローバル化、もしくは自己主権型への移行のための規模縮小である。一つ目の方法はすでに常套手段になりつつある。責任は、快適さを与える一方でプライバシーの侵害を受け入れ、不透明な行動をし、経済的な理由で顧客の利益に反することをするビジネスから、グローバルに活動する組織に移りつつあるのだ。自己主権型デジタルアイデンティティはこれとは逆の方法、つまりアイデンティティの管理責任はエンティティ自身に転嫁されるのである。この記事では個々のデジタルアイデンティティを管理するための新しいアプローチの機会と課題を議論し、ISÆNのコンセプトに基づいた実装について説明する。最終的には人間の概念を他のエンティティに拡張する可能性についても第4章で議論する。 2. 個人のための自己主権型デジタルアイデンティティ非中央集権型という概念は、世界規模のデジタルアイデンティティの問題を解決するためのアイデンティティ管理法として目に見えて浸透してきている。WWWの初期、IPアドレスはInternet Assigned Numbers Authorityによって付与されていた。この種の中央集権型アイデンティティは連合型アイデンティティによって淘汰された。その例として、Microsoft Passportは一つのアカウントで複数のインターネットサービスを利用できるようになった。その他企業はアイデンティティのベストプラクティスを探るべくLiberty Allianceを設立した。非中央集権への次のステップは、OpenIDのような取り組みに後押しされ、ユーザー自身が個人情報を管理することに重きを置き、アイデンティティ管理はサービスの利用から独立するべきであると強調したユーザー中心のアイデンティティの出現だった。しかし、現在でも未だ、デジタルアイデンティティを作成するのはGoogleやFacebookなど少数の、強大なサービスプロバイダである。結果的に、アイデンティティは個人ではなく企業によって管理されるという結果に落ち着いてしまっている。これにより、プロバイダ側がアイデンティティを取り消したり、ユーザーの介在なしに他サービスと連携することができてしまうようになった。 SSIは、個人がデジタルアイデンティティを作成し、管理できる次のステップになるはずである。SSIは以下の10の条件によって特徴付けられる。 プロバイダやアイデンティティ管理団体から独立してた個人のアイデンティティの存在 自らのアイデンティティを管理できる 自らのアイデンティティに完全にアクセスできる システムとアルゴリズムに透明性がある デジタルアイデンティティに永続性がある デジタルアイデンティティがポータブルである デジタルアイデンティティが相互接続可能である データエコノミーが実施されている 人権が保護されている SSIは個人が自らのデジタル情報を管理できるようにするが、言い換えればそれは各々のデータのプライバシーと信頼性を確立し、保持するための対策に個々が責任を持つということになる。デジタルアインデンティティが第三者による発行でないため、その信頼性は、デジタルアイデンティティの中の情報の正確性の根拠を持つ個人によってのみ達成されるのである。そしてその根拠は必要に応じて個人が提供する必要がある。例えば、デジタルアイデンティティに含まれる住所は登録団体で確認することができ、デジタルアイデンティティの本人は必要に応じてプロバイダにそれを提出することができる。すでに本人確認書類に対して自動確認を行う技術を提供しているIDカードも存在している。 これは信頼性の問題にもシフトしている。これまでのように情報の真正性を証明するのではなく、個人が「情報の根拠の真正性」を証明しなければならないからだ。これは第三者がその真正性を証明するために署名をすることで達成される。そしてこれらの根拠は、デジタルアイデンティティの情報の一部は変更可能であるがために、一定期間しか有効でないこともある。また、デジタルアイデンティティを有する個人が、どこの馬の骨かも分からない第三者から真正性の署名をもらい、それをプロバイダに提出することも考えられる。これに対して個人情報の受信者、つまりサービスプロバイダは「EUの公的機関の確認」など、取引に必要な一定レベルの信頼性を要求することができ、ユーザーはそれに適した署名を含む文書を提出することができる。 SSIの可能性上の10の条件に準じて、個人は、どこに住んでいようと、どのサービスプロバイダを選びどのSNSを使っていようと、無制限に自分のデジタルアイデンティティにアクセスできる。つまりSSIは個人の自由を拡大し、「Big Five」（Apple, Microsoft, Google, Amazon, Facebook）によってほとんどのデジタルアイデンティティが管理されている今日のインターネットの寡占構造を壊すことができるのである。 またこの10の条件は、すでに先述のID2020の基準: 人格、永続性、プライバシー、ポータビリティの要件を満たしている。もし、デジタルアイデンティティの信頼性が地域の政府機関に縛られなくなったら、移民や複数の居住地を持つ人は移住後も同じアイデンティティを保ち続けられるのである。この独立性は、紛争地域や腐敗した地域に住む人々に良いインパクトを与えるはずだ。 2018年から有効になる新しいEU一般データ保護規制（GDPR）では、データエコノミーとデータポータビリティ、より厳しい透明性を求めることで人権を保護している。この規制はまた、できるだけ高いデータ保護設定をデフォルトとする「Privacy by default」やプライバシー保護を重要な設計目標として掲げる「Privacy by design」の実装を呼びかけている。SSIは最大限のデータアクセスを個人に与えるだけでなく、Privacy by default/designを支持するプロバイダとの間で個人情報の選択的開示を可能にするのである。自己管理による透明性の確保はヨーロッパの不信の壁を取り除き、デジタル単一市場を活性化させることができる。企業にとっても、SSIは顧客に有益な情報を提供する義務を果たすための新たな方法になる。 SSIの課題ある個人がFacebook Connectのようなアイデンティティプロバイダを利用していた場合、その人は全てのアイデンティティ管理をそのサービスに委任することになる。このアイデンティティ管理にはプライバシーを守り、データの信頼性を担保する責任も含まれる。しかし、ほとんどの場合その人は自分のデジタルアイデンティティの扱いについてほとんど意見がない。むしろ自らのデジタルアイデンティティを引き換えに快適さを得ようとさえするのである。したがって、SSIのコアな課題は、個人が自分のデータを管理する努力を助けるソリューションを提供すること、言い換えればSSIを利用可能にするだけでなく、快適に利用できるようにすることである。これには個人の複数のデジタルアイデンティティの生成と管理、情報の信頼性の根拠の管理、そして他人との取引やログの記録の方法が含まれる。これまでの信頼できる第三者を避けるためにはより多くの、以下のような問題が発生する。 利用権利の取引におけるプライバシー保護。特に、第三者のプロファイリングを禁止するなどの複雑な問題におけるプライバシー保護 取引中の個人とサービス間の透明性。特に取引規約や内容の同意をとることなど 長期的な透明性を保つための、取引ログやデジタルアイデンティティの永続性 デジタルアイデンティティと、それを保証する根拠の信頼性 取引規約と実際のデータの使い方の一貫性 デジタルアイデンティティを安全にやりとりするためのデータフォーマットと標準化されたインターフェース これらの問題は全てが新しいものではなく、SSIだけの問題ではないものもあるが、この新しいアイデンティティの管理方法には、少なくとも現状のシステムに適応する新しい解決策が必要である。このうちいくつかの問題を解決するために、ブロックチェーンのような分散型台帳やスマート・コントラクトが、ログ記録、そしてデジタルアイデンティティの検証と個人情報や利用権の取引のための実装として提案されている。 一見、デジタルアイデンティティは管理区域とは無関係に存在しているように見える。しかし、取引で利用される法的枠組みの特定は、取引が行われている場所が「どこ」かという問に答えることが難しいばかりに、重要な問題になっているのである。このため、GDPRでは取引の実際の場所ではなく、取引に関係している人物の市民権に法的範囲を移すLex Loci Solutionsを導入している。つまりSSIを普及させるためには、個人やサービス提供者が適用される法的範囲を理解し、合法的に行動できるようにサポートする必要がある。 3. ISÆN: 人類のためのSSI標準化標準化の取り組みである、「個人データ所有、管理のための自己主権型識別子」のCENワークショップ84は2016年、人類のためのデジタルアイデンティティ管理方法としてISÆNコンセプトを提案した。このゴールはGDPRにそったSSI全体をカバーしたコンセプトにすることである。この標準化は以下をカバーすることを意図している。 人間によるコア・アイデンティティの生成 上のコア・アイデンティティからの取引を元にしたアイデンティティの派生 人間による明示的同意のリクエスト、承認の実装 公開されている分散型台帳の全てのログの記録 上記のコア・アイデンティティとは人間の特徴から構成され、名前などの識別機能だけでなくより生物的な特徴、フィンガープリントや顔認識データを含む。他のアイデンティティは取引一つ一つと結びつけられ、コア・アイデンティティからの一方向性関数で構成される。これにより、外部の人間が異なる取引のリンクを確立することなくアイデンティを証明することができる。そして改竄が防止されたメモリーへのログ記録は、誰がそのデータを処理したかの概要を把握することを可能にする。同時に、企業はデータの開示義務を果たすためにこういった取引プロトコルを活用でき、合法的なやりとりを立証できるのである。このコンセプトはドイツ連邦経済技術省の研究によって評価され、開発を進めることが推奨された。 4. Outlook: 物、組織のためのSSIIoTは中央管理実体を必要としない、モノを識別する強力なネットワークである。IoTにおけるモノの識別方法はデジタルアイデンティティを参照するバーコードやRFIDチップが主で、人間と同様にデジタルアイデンティティの非中央集権型管理も興味深いところである。 スマートコントラクトプロトコルはイーサリウムなどの公開された分散型台帳を通じたビジネスの取引の自動処理を可能にし、安全なデジタルアイデンティティはこのスマートコントラクトプロトコルを悪用した取引の実行を防ぐ。人間やモノに加えて、企業や組織のデジタルアイデンティティもSSIにおいて中心的な役割を果たすことになるだろう。 人間にSSIを適用する方法はすでに複数存在するが、人間以外のエンティティへ拡張するには新たな問題が生まれる。どうすればモノや組織に対するSSIを考案、実行できるのか？どうすればモノや組織は自身のアイデンティティを認識できるのか？モノや組織のどのような特徴を利用すれば、人間の生物的特徴のように固有で模倣が難しいアイデンティティを生み出せるのか？ 参照 Christopher Allen. (2016). The Path to Self-Sovereign Identities. from https://www.coindesk.com/path-self-sovereign-identity CEN WS ISÆN. (2016). Self-Sovereign Identifier(s) for Personal Data Ownership and Usage Control. from https://www.cen.eu/work/areas/ICT/Pages/WS-ISÆN.aspx Civic. (2017). Civic.com. Retrieved from https://www.civic.com Ethereum Foundation. (2017). ethereum - Blockchain App Platform. Retrieved from https://www.ethereum.org/ EUR-Lex. (2014, July 23). Verordnung (EU) Nr. 910/2014 des Europäischen Parlaments und des Rates vom 23. Juli 2014 über elektronische Identifizierung und Vertrauensdienste für elektronische Transaktionen im Binnenmarkt und zur Aufhebung der Richtlinie 1999/93/EG. Retrieved October 31, 2017, from http://eur-lex.europa.eu/legal- content/DE/ALL/?uri=CELEX:32014R0910 EUR-Lex. (2016, April 4). Verordnung (EU) 2016/679 des Europäischen Parlaments und des Rates vom 27. April 2016 zum Schutz natürlicher Personen bei der Verarbeitung personenbezogener Daten, zum freien Datenverkehr und zur Aufhebung der Richtlinie 95/46/EG (Datenschutz-Grundverordnung). Retrieved October 31, 2017, from http://eur- lex.europa.eu/legal-content/DE/TXT/?uri=CELEX:32016R0679 ævatar.coop. (2017). aevatar.com. Retrieved from https://aevatar.com Humaniq. (2017). Humaniq.com. Retrieved from https://humaniq.com ID2020. (2017). An Alliance Committed to Improving Lives Through Digital Identity. Retrieved from http://id2020.org/ Jähnichen, S., Weinhardt, C., Müller-Quade, J., Huber, M., Rödder, N., Karlin, D., . . . Shaar, P. (2017). Sicheres Identitätsmanagement im Internet: Eine Analyse des ISÆN-Konzepts (Individual perSonal data Auditable addrEss) durch die Smart-Data-Begleitforschung im Auftrag des Bundesministeriums für Wirtschaft und Energie. http://www.digitale- technologien.de/DT/Redaktion/DE/Downloads/Publikation/smartdata_studie_isaen.html. Jacobovitz, O. (2016). Blockchain for Identity Management. The Lynne and William Frankel Center for Computer Science Department of Computer Science. Beer Sheva, Israel: Ben-Gurion University. Keesing Technologies. (2017). AuthentiScan; Professional Authentication. Straight forward solution. Retrieved October 31, 2017, from https://www.keesingtechnologies.com/automated-id-checking/ Meitinger, T. H. (2017). Smart Contracts. Informatik-Spektrum(40), 371-375.Nakamoto, S. (2008). Bitcoin: A Peer-to-Peer Electronic Cash System. Retrieved 2017, from http://bitcoin.org/bitcoin.pdf Pilkington, M. (2016). Blockchain Technology: Principles and Applications. In F. X. Olleros, &amp; M. Zhegu (Eds.),Handbook of Research on Digital Transformations. Rannenberg, K., Camenisch, J., &amp; Sabouri, A. (Eds.). (2015). Attribute-based Credentials for Trust: Identity in theInformation Society. Springer. United Nations. (2015). UN Sustainable Development Goals. Retrieved October 31, 2017, fromhttp://www .un.org/sustainabledevelopment/ United Nations. (2016, January 2016). 244 million international migrants living abroad worldwide, new UN statistics reveal . Retrieved October 31, 2017, from UN Sustainable Goals: http://www .un.org/sustainabledevelopment/blog/2016/01/244-million-international-migrants-living- abroad-worldwide-new-un-statistics-reveal/ Verifiable Claims Working Group. (2017). About the Verifiable Claims Working Group. Retrieved from https://www.w3.org/2017/vc/WG/","link":"/2020/12/25/cornell/"},{"title":"Eslint&amp;Prettierとhuskyで幸せになろう！","text":"PrettierやEslintを毎度毎度コマンドから動かしてフォーマットするのもかったるいので、huskyでコミット時に自動整形してくれるように設定したいと思います。eslintrc等はnpmモジュール用の設定で進めるのでご了承ください。 開発環境パッケージ管理 : npm OS : Mac OS 言語 : Node.js Eslintをインストールする1yarn add eslint Eslint init1./node_modules/eslint/bin/eslint.js --init ここで色々質問されるので、お好みで答えていきましょう。各質問の詳細はこちらの記事がおすすめ Prettierをインストールする1yarn add prettier eslint-config-prettier eslint-plugin-prettier -D eslintrc.jsの設定先ほどのeslint initで自動的に生成された.eslintrc.js(.eslint.json,.eslint.ymlnの場合もある)をPrettier用に設定します 12345678910111213141516171819202122232425262728293031323334module.exports = { env: { commonjs: true,//requireを有効にする es6: true,//importを有効にする es2020: true,//最新のEcmaScriptを有効にする node: true,//Webアプリなどブラウザで使用するコードの場合はbrowser:true mocha: true,//テストでmochaを使う場合は追記しないとエラーが出る }, extends: ['eslint:recommended', 'plugin:prettier/recommended'],//eslintとprettier両方を追加 parserOptions: { ecmaVersion: 11, }, rules: { //eslintの設定 indent: ['error', 2],//インデントはスペース2個分 quotes: ['error', 'single'],//文字列はシングルクオート semi: ['error', 'always'],//セミコロンを必須に 'linebreak-style': ['error', 'unix'],//改行スタイルをunixに 'no-var': 'error',//varを使ったらエラー 'prefer-const': 'error',//再代入のないconstはエラー 'prefer-arrow-callback': 'error',//アロー関数でコールバック関数を書く //prettierの設定 'prettier/prettier': [ 'error', { useTabs: false,//インデントはタブではなくスペース singleQuote: true,//文字列はシングルクオート semi: true,//セミコロン必須 tabWidth: 2,//インデントはスペース2個分 printWidth: 120,//一行は120文字まで }, ], },}; 注意点としては、prettierとeslintでルールが競合してしまうとエラーが止まらなくなってしまうので必ずルールは矛盾させないこと。 huskyとlint-stagedインストール1yarn add husky lint-staged -D でも良い husky,lint-stagedの初期設定1npx mrm lint-staged package.jsonの設定12345678910111213141516171819\"lint-staged\": { \"*.js\": [ \"prettier '**/*.{js,jsx,ts,tsx,vue}' --write\",//js,jsx,ts,tsx,vueファイルを整形 \"eslint --fix\"//eslintで全部整形(.eslintignoreを設定すれば対象外のファイルを指定できる) ]},\"husky\": { \"hooks\": { \"pre-commit\": \"lint-staged\"//commit時にlint-stagedを実行 }},//prettierの設定\"prettier\": { \"useTabs\": false, \"singleQuote\": true, \"semi\": true, \"tabWidth\": 2, \"printWidth\": 120}, もしこれでうまく動かないことがあれば、コメント欄で教えていただけると嬉しいです。 参考文献https://stackoverflow.com/questions/50048717/lint-staged-not-running-on-precommithttps://qiita.com/berry99/items/d1ca66b477f48856256d","link":"/2020/08/15/ephusky/"},{"title":"Encoding, Encryption, Hashing, Obfuscationの意味","text":"ある日ネットサーフィンをしていたらEncoding vs. Encryption vs. Hashing vs. Obfuscationという記事を見つけた。この四つの単語はそれぞれ実際には全く違う意味なんだけど「違いを説明せよ」と突然言われたら確かに説明できないなぁ、と思ったので元記事の内容に沿って各単語の意味を整理しておきます。 各単語の概要Encodingデータをある一定の規則に基づいて可逆な別のデータに変換すること。和訳は符号化。 Encryptionデータをアルゴリズムを使って特定の「鍵」によって復号可能な別のデータに変換すること。和訳は暗号化。 Hashingデータをアルゴリズムを使って非可逆な別のデータに変換すること。和訳はハッシング。 Obfuscationデータの意味は変えないまま人間にとって読みにくい別のデータに変換すること。和訳は難読化。 Encoding 和訳 : 符号化 可逆 符号化は比較的幅広い分野で当てはまる概念である。脳科学においても符号化（記銘）という概念があり、言語の翻訳もある意味では符号化である。またカメラの画像処理やアナログ音声のA/D変換においても符号化の概念が利用されている。挙げていくとキリがなくてただでさえ短い夏休みが無駄になってしまうので全て調べ上げることはできないが、要するに、「あるデータを誰かにとって理解しやすいデータに規則正しく変換する」というのが符号化の意味である。この概念を応用した例としてはデータの圧縮なども挙げられる。 情報科学であればコンピュータ、脳科学であれば脳、言語学であればその国の人にとって理解しやすいデータの形を作ってあげるのが、符号化の仕事であり、概念である。この記事を見ているであろう技術者の方に馴染みのある例をあげればUnicodeやBase64、ASCIIなどが符号化データに当たる。&nbsp;&nbsp;上記で述べた概念を用いれば、DNSサーバーでURLをIPアドレスに変換する処理も、通信プロトコルが理解しやすいデータに変換するという意味では符号化に当てはまる。実際の通信では2進数でやりとりされるIPアドレスを人間様の読みやすいように10進数に変換する処理もまた、符号化である。 Encryption 和訳 : 暗号化 可逆 暗号化は主に情報通信において使われることが多い。暗号の起源として知られるものとして ヒエログリフ(象形文字)が挙げられるが、ヒエログリフそのものに秘匿性の意図はなく、単に後世で解読にえげつなく時間がかかったというだけなので厳密には暗号ではないとされている。古代から近代にかけては主に軍事的な目的で暗号が発明されることが多く、有名なシーザー暗号やドイツ軍のエニグマの暗号方式などもその一つである。古代の暗号から共通する目的として、データを秘密に保つことが挙げられる。これに関しては直感的に分かりやすいので詳しく説明する必要はないが、カッコよく言えば「秘匿性」である。&nbsp;&nbsp;現代の情報通信における暗号化では、一つの通信で使われる暗号アルゴリズムなどを、暗号スイートという文字列で表す。例えば、 1ECDHE-RSA-AES128-GCM-SHA256 という暗号スイートがあった場合、鍵交換にはECDHE、鍵認証にはRSA、暗号化アルゴリズムにはAES128、暗号モードはGCM、ハッシュ関数にはSHA-256が使われているということを示す。 ＊鍵認証と暗号化アルゴリズムの間に「_WITH_」が入る場合もある Hashing 和訳 : ハッシング 非可逆 ハッシングは主に情報通信で使われ、アルゴリズムに基づいてあるデータを一見乱数に見える解読不可能で非可逆な別のデータに変換することをいう。暗号化と違って秘匿性の目的はなく、主に検索の高速化や改竄検知に使われる。&nbsp;&nbsp;例えば、ハッシュ探索アルゴリズムは一般的な線形探索アルゴリズムに比べて高速な処理が期待でき、ハッシュを利用したLandmark-based fingerprintingはShazamの音声類似性検索のアルゴリズムにも採用されている。改竄検知でいえば、最も有名なのがSHA-1, SHA-2ハッシュ関数である。改竄検知の方法としてはデータをハッシュ化して暗号化したデータと共に送信し、受信側がデータを復号してハッシュ化した際に元のハッシュ値と違った場合に改竄が検出されるというものである。SHA-1に関しては2005年から脆弱性が指摘され、2017年にGoogleが実際に攻撃に成功したことが決定的となって利用は大幅に減少した。2020年7月にIPAから公開されたCRYPTRECの利用禁止暗号アルゴリズムにもノミネートされている。 Obfascation 和訳 : 難読化 可逆 難読化とは、主にソースコードの解析防止や知的財産権の保護を目的として敢えて読みにくいコードに変換することである。概念を説明すれば「誰かにとって扱いにくいデータに変換する」、つまり概念的には符号化の対極に位置するものとも言える。難読化がソースコードの文脈以外で使われている例はぶっちゃけ思いつかないし、ググっても出てこないので「難読化=ソースコードの難読化」と考えて良いだろう。&nbsp;&nbsp;ソースコードを難読化する理由としては、上述のように、実装している独自アルゴリズムのパクリや機能制限の回避を目的としたリバースエンジニアリングを防ぐ目的がほとんどである。実際JavaScriptやPythonなど、主要なスクリプト言語ほぼ全てに難読化パッケージ/ツールがあるが、手作業でやるのは単純に初心者がコードを書くのと一緒になってしまうので完全に時間の無駄である。 ＊筆者の場合は自分が書くコードは無意識に難読化されているので難読化ツールは特に必要ない。&nbsp;&nbsp;ここからは筆者の個人的な意見だが、個人プロジェクト以外のコードはほぼ確実に他人と共有する必要があり、その時に難読化されたコードをレビューしろとか改変しろとか言われたらたまったもんじゃない。なので本当に隠したい処理はサーバーサイドで書き、どうしてもクライアントサイドで書かなければならない場合は開発が終了して保守のフェーズに入る際に難読化することをお勧めする。 といった感じでできるだけ各単語の概念を踏まえて整理したので、参考にしていただけるとありがたいです。&nbsp;&nbsp;「ここ違うぜ」と思った方はコメントで教えていただけると非常に勉強になるので嬉しいです。 参考文献https://www.netagent.co.jp/study/blog/hard/20180726.html https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/ https://www.geeksforgeeks.org/encryption-encoding-hashing/ https://www.packetlabs.net/encryption-encoding-and-hashing/","link":"/2020/08/10/enword/"},{"title":"Font Access APIを使う","text":"Chrome87よりブラウザ上でインストール済みのフォントを調べるFont Access APIがOrigin Trialsに公開されました。正直このAPIで何か作ろうとは思っていませんが、このAPIを欲するいつの日かのために少し調べたので書き残しておきます。 Quick StartOrigin Trialsでトークンを取得するOrigin Trialsを利用したことがある方は飛ばして大丈夫です。まずはChrome FlagsのFont Access APIをenableに変更します。その後Origin TrialsページのLocal Font AccessをRegisterします。するとトークンが発行されますので 1&lt;meta http-equiv=\"origin-trial\" content=\"ここにトークンを貼る\"&gt; このmetaタグをソースコードに挿入します。 APIが使えるかどうかまずこのAPIが使用できるかどうかを確認しておきましょう。 12345678if(!'fonts' in navigator) return;const status = await navigator.permissions.query({ name: \"font-access\" }); if (status.state === \"granted\") console.log(\"permission was granted 👍\"); else if (status.state === \"prompt\") console.log(\"permission will be requested\"); else console.log(\"permission was denied 👎\"); Chrome87以上であれば問題ありませんがそうでないブラウザの場合は他の処理で代用するしかないでしょう。 フォントオブジェクトを取得する1const iterableFontObject = navigator.fonts.query(); この変数には非同期イテレータ(Asynchronous Iterator)が代入されます。つまりfor await ofでイテレート処理ができるわけです。 メタデータを取得する123456for await (const metadata of iterableFontObject) { const fontFamily = metadata.family; // e.g.ComicSansMS const postscriptName = metadata.postscriptName; // e.g.Comic Sans MS const fullName = metadata.fullName; // e.g.Comic Sans MS console.log(fontFamily, postscriptName, fullName);} 現状文字列として取得できるデータはこの3つのようです。postscriptNameは確実にユニークで、OpenTypeフォーマットでなくてもUserAgentがよしなに導出してくれるようです。非同期イテレータはObject.keys().lengthではフォント数の算出はできないので、イテレートついでに数えておくのが一番手っ取り早いかと。 SFNTデータにアクセスするTrueType, OpenType, WOFFなどが得られるというわけです。これに関してはまじで使い道が分からん。とりあえず実装していきます。123456789## SFNTバージョンを取得する```javascriptconst fonts = navigator.fonts.query();for await (const metadata of fonts) { const sfnt = await metadata.blob(); const sfntVersion = (new TextDecoder).decode( await sfnt.slice(0, 4).arrayBuffer() );} 1234567891011121314151617ただこのままではなんのデータか分からないので拡張子形式に変換していきましょう。```javascriptfor await (const metadata of fonts) { let outlineFormat = 'UNKNOWN'; switch (sfntVersion) { case '\\x00\\x01\\x00\\x00': case 'true': case 'typ1': outlineFormat = '.ttf'; break; case 'OTTO': outlineFormat = '.cff'; break; } console.log('Format Extension:', outlineFormat, metadata.family);} 現在AppleでサポートされているフォントはTrueType(.ttf)かPostscript(.cff)のどちらかなので、それに合わせてSFNTバージョンを絞っていきます。これまじで何に使うんだろうか。 セキュリティの懸念と対策最近File System Access APIなどローカルのシステムにアクセスするAPIが増えていますが、やはり怖いのはセキュリティです。 フィンガープリント対策Font Access APIは取得したフォントをアルファベット順にソートして返します。これは、システムにインストールされた順番のままフォントのリストを返してしまうと、フィンガープリントに利用され、ユーザーの識別に使われる可能性が高いからです。数百のフォントを全く同じ順番でインストールする複数のユーザーなどそういないですからね。 リクエストシステム最初の方のパーミッションリクエストの部分がこれです。メタタグを使用してリクエストを送信しない限り使用できないようにすることでAPIの濫用を防いでいます。https://chromium.googlesource.com/chromium/src/+/lkgr/docs/security/permissions-for-powerful-web-platform-features.md (この記事でも先述のFile System Access APIがケーススタディとして紹介されています)ただ、最初にメタタグなしでパーミッション確認もなしで実行してみたところ普通に動いてしまったので、筆者も???となっているところです。 ユーザーの実行動作実はこのAPIは今までのコードを非同期即時関数に入れただけでは動きません。ロードしたら自動的に動作することを許可すると大抵良いことはないので、ボタンをクリックする、何かのキーを打つなどユーザーが自ら実行することでしか動かないような仕様になっています。(e.g.~.addEventListner()) 確認ダイアログの表示このAPIを実行する動作をユーザーが行うと、このダイアログが表示されます。これは他のローカルにアクセスするAPIでも同様の仕様のものが多いです。 デモとソースコードChromeのWebDevチームがGlitchにデモサイトとコードを公開しています。 https://local-font-access.glitch.me/demo/ ほぼ似たようなものですが僕の書いたソースコードも投げておきます。 Quick Startの方12345678910111213141516171819const AccessFont = async () =&gt; { const status = await navigator.permissions.query({ name: \"font-access\" }); if (status.state === \"granted\"){ console.log(\"permission was granted 👍\"); } else if (status.state === \"prompt\") { console.log(\"permission will be requested\"); } else { console.log(\"permission was denied 👎\"); } const iterableFontObject = navigator.fonts.query(); let total = 0; for await (const metadata of iterableFontObject) { console.log(metadata.fullName); total++; } console.log(`Total number of local fonts : ${total}`);}const button = document.getElementById(\"test\");button.addEventListener(\"click\", AccessFont); // ユーザーの動作がないと動かせない SFNTアクセスの方1234567891011121314151617181920212223const AccessSFNT = async () =&gt; { const fonts = navigator.fonts.query(); for await (const metadata of fonts) { const sfnt = await metadata.blob(); const sfntVersion = (new TextDecoder).decode( await sfnt.slice(0, 4).arrayBuffer() ); let outlineFormat = 'UNKNOWN'; switch (sfntVersion) { case '\\x00\\x01\\x00\\x00': case 'true': case 'typ1': outlineFormat = '.ttf'; break; case 'OTTO': outlineFormat = '.cff'; break; } console.log('Format Extension:', outlineFormat, metadata.family); }}const access = document.getElementById(\"access\");access.addEventListener(\"click\", AccessSFNT); // ユーザーの動作がないと動かせない 終わりに最初に記事を書いたときは本気で何に使うのか分からないAPIでしたが、どうやらFigmaとかその他デザインアプリケーション、CADに特化したフォントをWebで使う際に役立つようです。 Bringing design apps like Figma, Gravit, and Photopea, to the web is great.For example, corporate logo fonts, or specialized fonts for CAD and other design applications. https://developers.google.com/web/updates/2020/11/nic87#font-access 参考文献WICG仕様書 Web.devチームブログ(最初に読むならこれ) Web.devチームGlitchデモ Chrome87の新機能まとめ(公式) Chrome Platform Status APIのパーミッションに関するChromeの文献 https://nixeneko.hatenablog.com/entry/2018/06/20/000000","link":"/2020/12/04/faaapi/"},{"title":"Pythonで3.14を感じてみる","text":"単に円周率を使いたいなら 12import mathprint(math.py) で良いんだけども、3.14がどうやって求まっているのか自分でやってみたい。というわけで確率的モデルで円周率を求めていきたいと思います。 第一象限の適当なところに点を打っていくまずx座標とy座標それぞれで、0から1のランダムな数値を定めて点を打ちます 12import randomx, y = random.random(), random.random() x^2+y^2が1以内かどうか確かめるこのxとyをそれぞれ2乗してお互いに足し合わせた数が1以内であれば、点は半径1の円の内側にあることになります。 1number = x ** 2 + y ** 2 #これが1以内であれば円の内側 何回も繰り返して近似値を見るこれを何回も繰り返して、繰り返した数を分母、1以内だった回数×4(全ての象限で同じ結果になると仮定する)を分子とすると、円周率が算出されます。試しに1000回くらい繰り返してみましょう。 12345678910111213141516171819import randomincount = 0def GenerateRandom(): x, y = random.random(), random.random() number = x ** 2 + y ** 2 return numberiteration = 1000for ite in range(iteration): check = GenerateRandom() if (check &lt; 1): incount += 1quadrant = 4 #全象限print(incount * quadrant / iteration) 13.2 うーん、微妙。数が少なかったようなので1000万回で試してみましょう。 12# 5秒くらいかかります3.141382 良きかな。 可視化してみる数字が出ただけだとあんまり感動しなかったのでmatplotlibで可視化してみましょう。 まずは1000回バージョン 123456789101112131415161718192021import randomimport matplotlib.pyplot as pltdef GenerateRandom(): x, y = random.random(), random.random() number = x ** 2 + y ** 2 return [number, x, y]iteration = 1000for ite in range(iteration): check = GenerateRandom() if (check[0] &lt; 1): plt.scatter(check[1], check[2], c = 'red', s = 10) else: plt.scatter(check[1], check[2], c='blue', s = 10)plt.title('Monte Carlo Method')plt.xlabel(\"x\")plt.ylabel(\"y\")plt.show() 10秒くらい待つと… イマイチ分かりにくいので1000万回バージョンをみてみましょう。 123456789101112131415161718192021import randomimport matplotlib.pyplot as pltdef GenerateRandom(): x, y = random.random(), random.random() number = x ** 2 + y ** 2 return [number, x, y]iteration = 10000000for ite in range(iteration): check = GenerateRandom() if (check[0] &lt; 1): plt.scatter(check[1], check[2], c = 'red', s = 10) else: plt.scatter(check[1], check[2], c='blue', s = 10)plt.title('Monte Carlo Method')plt.xlabel(\"x\")plt.ylabel(\"y\")plt.show() これを実行したら一旦パソコンから離れて散歩でもしましょう。帰ってきた頃には処理が終わっているはずです。 グラフを正方形にすればより分かりやすいですが、綺麗に弧を描いて分布しているのが分かります。 これを計算したからといって何か生まれるわけでもありませんが、興味を持った方は試していただけると嬉しいです。 参考情報処理学会のYouTube","link":"/2020/09/25/pypy/"},{"title":"File System Access APIを使ってみる","text":"以前までChromeのOrigin TrialsにNative File System APIとして実装されていたローカルファイルへアクセスするAPIが、ついにChrome86から標準機能として搭載され、名前も実装もだいぶ変わっていたので記事に残しておきます。 このAPIはChromeバージョン86以降のみ対応しています。他ブラウザ、Chrome85以前では動きませんのでプロダクション環境に実装する予定の方はご注意ください（というかおやめください）。 File System Access APIFile System Access APIは主にローカルファイルの読み取り、書き取りを目的としたAPIです。実はファイルだけでなくフォルダの読み取り/書き取りもできますが、今回はファイルの読み取り/書き取りの方法を紹介します。 ファイルを読み取るこれまでローカルファイルを読み取るにはこの記事みたいに自分でHTMLタグを足したり、ファイル内容を切ったり貼ったりする必要があり、かなり面倒くさい実装が不可欠でした。一方File System Access APIではたった３行で読み込みが完了します。 123[fileHandle] = await window.showOpenFilePicker();const file = await fileHandle.getFile();const fileContents = await file.text(); このfileContentsをtextareaに代入すれば手軽にファイルの読み取りが完了します。 読み取りオプション１行目のshowOpenFilePickerは引数でオプションの設定も可能です。 1234// 複数ファイルの選択を可能にする[fileHandle] = await window.showOpenFilePicker({multiple: true});// 複数ファイルの選択を不可能にする[fileHandle] = await window.showOpenFilePicker({multiple: false}); 参考 fileHandleの中身12345678{ lastModified: 1587625257478 // ファイル最終更新日時(UNIXタイム) lastModifiedDate: Thu Apr 23 2020 16:00:57 GMT+0900 (日本標準時) {} // ファイル最終更新日時 name: \"sample.pdf\" // ファイル名 size: 85488 // ファイルサイズ (単位はバイト) type: \"application/pdf\" // ファイルタイプ （記述のない場合もある） webkitRelativePath: \"\" // フォルダを選択した際に内部のファイル数などを表示できる} ファイルに書き込む従来のブラウザではそもそも上書きすることが不可能だったのですが、こちらもFile System Access APIでは簡単に書けちゃうんです。 123const writable = await fileHandle.createWritable();await writable.write(contents/*⇦書き込む内容*/);await writable.close(); さっきファイル情報を代入したfileHandleにcreateWritableメソッドでFileSystemWritableFileStreamオブジェクトを呼び出します。その後書き込んで、終了するだけ。非常に簡潔な仕様です。 この時ブラウザではこんな感じのダイアログが表示され、「変更を保存」ボタンを押すとローカルファイルの上書きが完了します これ以降、新たなファイルを読み込むかリロードや手動でfileHandleをリセットするまでは上書き処理を行うと自動でこのファイルが上書きされます。便利な反面、実装を間違えると取り返しのつかないことになりますのでご注意ください。 その他の機能FileSystemAccess APIは基本は読み取り/書き込みのみですが、深掘りしていけば色々応用できそうです。ChromeのブログにはBlob型（画像や音声を取り扱える）の読み取りと書き込みをHTTPリクエストで可能にする方法も少し書いてあるので興味のある方は見てみてください。他にも上書きするファイルを再度ファイルピッカーを起動して選ぶ方法もあったりします。 おわりにこのAPIはこれまで試験的機能だったこともあってまだ枯れていない段階です。実際、ドラッグ&amp;ドロップ機能なども実装はされていますが問題も多く議論が行われている最中です。 APIの性質上セキュリティがおざなりになるとChromeの脆弱性になり得るので議論中の機能は使うべきではありませんが、今後の動向には注目していきたいです。 参考文献WICG仕様書…https://wicg.github.io/file-system-access/WebDevチームブログ…https://web.dev/file-system-access/","link":"/2020/11/22/fsaapi/"},{"title":"毎朝5時にGoogle Formに自動回答したい","text":"みなさんこんにちは。夏ですね。僕もついに部活動が再開し、ワクワクドキドキな訳ですが、一昨日の夜顧問からこんな連絡がきました。 12- 毎朝5時20分までに検温を行い、結果をGoogleFormから報告してください- 報告がなかった部員は朝練の参加を認めません そもそも朝練が6時半から始まる時点でイッているので5時20分に連絡しろと言われてもさほど驚かなかったのですが、ここで一つ問題が発生しました。 というのも僕は普段朝5時に起き、そのままパンをかじりながら自転車で駅に向かうので、検温をする時間がないのです。もう少し早起きすれば済む話なのですが、4時起きは流石にきついし体がもたないのでやりたくない。かといって5時に起きて検温なんかしていたら朝練そのものに遅れてしまう。 というわけで、朝5時くらいに、心配されない程度の体温をよしなに指定のFormに入力して送信してくれるプログラムを作りたいと思います。 Seleniumでフォームを送信する本物のフォームを使ってやると僕の身元がバレてしまうので、今回はテスト用に僕が作成した本物と同じ内容のフォームで実装したいと思います。 初期値入力つきURLを用意するGoogle Formは、パラメータをつけることで各質問の値を入力した状態でURLを開くことができます。普通にフォームを開く際のURLは https://docs.google.com/forms/d/e/1FAIpQLScGgZ8dsBkcSVutvW3JgDLqy3pIEKk12ucjiA8mNQrKopILog/viewform?usp=sf_link こんな感じでviewformの後に「usp=sf_link」というパラメータがついています。このパラメータは事前入力のない、ピュアな回答フォームであることを示しているので、まずここを「usp=pp_url」に変えて、事前入力があることを知らせてあげます。&nbsp;&nbsp;そしたら次に各質問の回答をパラメータに入力していきます。フォームの各質問を識別する番号があるので、Chromeの検証画面で質問のdivを探し、2階層目で以下のような番号を探します。番号を見つけたらentry.番号=回答内容の形でパラメータを加えます。今回は名前と体温をテキストで入力するので以下のようなURLになります。 https://docs.google.com/forms/d/e/1FAIpQLScGgZ8dsBkcSVutvW3JgDLqy3pIEKk12ucjiA8mNQrKopILog/viewform?usp=pp_url&amp;entry.1534939278=荒川智則&amp;entry.511939456=36.5しかしこのままだと毎日36.5度を報告することになり、流石に怪しまれるので、乱数で良い感じに値を振ります。 1234# 36.1~36.7の間でランダムに値を生成して文字列変換body_temp = str(36 + random.randint(1,7)/10)# URLの最後に加えるurl = 'https://docs.google.com/forms/d/e/1FAIpQLScGgZ8dsBkcSVutvW3JgDLqy3pIEKk12ucjiA8mNQrKopILog/viewform?usp=pp_url&amp;entry.1534939278=荒川智則&amp;entry.511939456='+body_temp Seleniumで自動提出URLが完成したら、あとはSeleniumでURLを開き、ポチッと提出ボタンを押してもらうだけです。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# SeleniumとChromedriverをpipでインストールしておくfrom selenium import webdriverimport chromedriver_binaryimport timeimport randombody_temp = str(36 + random.randint(1,7)/10)url = 'https://docs.google.com/forms/d/e/1FAIpQLScGgZ8dsBkcSVutvW3JgDLqy3pIEKk12ucjiA8mNQrKopILog/viewform?usp=pp_url&amp;entry.1534939278=荒川智則&amp;entry.511939456='+body_temp# クリックの関数def click(xpath): driver.find_element_by_xpath(xpath).click()# パスワード入力の関数def insert_pw(xpath, str): driver.find_element_by_xpath(xpath).send_keys(str)driver = webdriver.Chrome()driver.implicitly_wait(1)driver.get(url)moving_login_button = '/html/body/div[2]/div/div[2]/div[3]/div[2]'time.sleep(1)# Googleアカウントでのログインが必要な場合はログインするif(driver.find_elements_by_xpath(moving_login_button) != []): click(moving_login_button) login_id = \"{Googleアカウントのメアド}\" login_id_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[1]/div/form/span/section/div/div/div[1]/div/div[1]/div/div[1]/input' login_id_button = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[2]/div/div[1]/div/div' insert_pw(login_id_xpath, login_id) click(login_id_button) time.sleep(1) login_pw = \"{Googleアカウントのパスワード}\" login_pw_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[1]/div/form/span/section/div/div/div[1]/div[1]/div/div/div/div/div[1]/div/div[1]/input' login_pw_button = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[2]/div/div[1]/div/div' insert_pw(login_pw_xpath, login_pw) time.sleep(1) click(login_pw_button)time.sleep(1)submit_button = '//*[@id=\"mG61Hd\"]/div[2]/div/div[3]/div[1]/div/div'click(submit_button)print(\"Done!\")driver.close# メモリーを食うのでちゃんと終了しましょうdriver.quit しっかり送信できました。 定期イベントにするコードが書けたらあとは定期イベント化するだけなのですが、ここで少しつまづいたのでやり方を説明しておきます。&nbsp;&nbsp;当初予定していた方法としてはAutomatorでアプリ化し、カレンダーに入れて毎日実行する方法(参考)。これなら報告しなくて良い日はカレンダーから外せば良いし、完璧なはず。と思ったのですが、PCをシャットダウンしていると動作しないためボツ。crontabに設定して定期イベント化する方法も同様の理由でボツ。 結局臨機応変にイベントの変更はできないものの、PCの状態にかかわらず実行してくれるAWSのLambdaを使用することに決めました。(Lambdaの使い方はこのサイトとかが参考になりました) LambdaのレイヤーにSeleniumとChromedriver、headless-chromiumを上げるLambdaでライブラリを使うには各フォルダをzipに圧縮してレイヤーにアップロードする必要があります。今回はSeleniumとChromeのWebdriverであるChromedriver、それからChromeを開かずにスクレイピングを行うためのheadless-chromiumを使用するので、それぞれzipに圧縮してレイヤーに上げていきます。 1. Selenium1234567mkdir seleniumcd seleniummkdir pythoncd pythonpip install selenium -t .cd ../zip -r selenium.zip ./python できたzipファイルをそのままレイヤーにアップロードします。 2. Chromedriverとheadless-chromium12curl https://github.com/adieuadieu/serverless-chrome/releases/download/v1.0.0-55/stable-headless-chromium-amazonlinux-2017-03.zip &gt; headless-chromium.zipcurl https://chromedriver.storage.googleapis.com/2.43/chromedriver_linux64.zip &gt; chromedriver.zip できた二つのzipファイルを解凍し、headless-chromeフォルダにまとめます。その後そのheadless-chromeをzipに圧縮してレイヤーにアップロードします。 3. レイヤーを関数に適用関数の下にある「Layers」を押し、下の「レイヤーの追加」ボタンから二つのレイヤを追加します ※注意※ Lambda関数のランタイムをPython3.8にするとChromedriverが動いてくれなかった(原因不明)ので、ランタイムはPython3.6か3.7に設定することをお勧めします。 headless-chromiumとChromedriverの間に互換性がないと動作しないのでこちらから最新版を入手しても動作しない可能性があります。 Lambda用にコードを少し変える筆者は今までCloud9以外のAWSツールを使ったことがないへっぽこコーダーなので、色んなサイトの見様見真似でなんとかLambdaで動くコードにしました。先人に感謝。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import jsonfrom selenium import webdriverimport timeimport randomdef lambda_handler(event, context): body_temp = str(36 + random.randint(1,7)/10) url = 'https://docs.google.com/forms/d/e/1FAIpQLScGgZ8dsBkcSVutvW3JgDLqy3pIEKk12ucjiA8mNQrKopILog/viewform?usp=pp_url&amp;entry.1534939278=荒川智則&amp;entry.511939456='+body_temp options = webdriver.ChromeOptions() options.binary_location = '/opt/headless-chrome/headless-chromium' # このオプション4つを付けないとChromeは起動せずエラーになります options.add_argument('--headless') # サーバーレスでChromeを起動 options.add_argument('--no-sandbox') # sandbox外でChromeを起動 options.add_argument('--single-process') # タブ/サイトごとのマルチプロセスではなく、シングルプロセスへ切り替える options.add_argument('--disable-dev-shm-usage') # メモリファイルの出力場所を変える driver = webdriver.Chrome('/opt/headless-chrome/chromedriver',options = options) driver.implicitly_wait(1) driver.get(url) def click(xpath): driver.find_element_by_xpath(xpath).click() def insert_pw(xpath, str): driver.find_element_by_xpath(xpath).send_keys(str) moving_login_button = '/html/body/div[2]/div/div[2]/div[3]/div[2]' time.sleep(2) if(driver.find_elements_by_xpath(moving_login_button) != []): click(moving_login_button) # 環境変数でMY_GMAILにGoogleアカウントのメアドを設定してください login_id = MY_GMAIL login_id_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[1]/div/form/span/section/div/div/div[1]/div/div[1]/div/div[1]/input' login_id_button = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[2]/div/div[1]/div/div' insert_pw(login_id_xpath, login_id) click(login_id_button) time.sleep(1) # 環境変数でMY_PASSWORDにGoogleアカウントのパスワードを設定してください login_pw = MY_PASSWORD login_pw_xpath = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[1]/div/form/span/section/div/div/div[1]/div[1]/div/div/div/div/div[1]/div/div[1]/input' login_pw_button = '/html/body/div[1]/div[1]/div[2]/div/div[2]/div/div/div[2]/div/div[2]/div/div[1]/div/div' insert_pw(login_pw_xpath, login_pw) time.sleep(1) click(login_pw_button) time.sleep(1) submit_button = '//*[@id=\"mG61Hd\"]/div[2]/div/div[3]/div[1]/div/div' click(submit_button) driver.close driver.quit return { 'statusCode': 200, 'body': json.dumps('Form submission success!!') } 注意点 Chromeの起動オプション--headless,--no-sandbox,single-process,--disable-dev-shm-usageを付けないとLambda上で正常に起動せず、エラーが出ます。各オプションについての詳細はこちらをご覧ください レイヤーにアップロードしたファイルはoptディレクトリの配下に置かれます。パスを指定する際はopt/ディレクトリ名/…の形で表記しましょう CloudWatch Eventsでトリガーを設定 関数の「Layers」をクリックして「トリガーを追加をクリック」し、ドロップダウンから「EventBridge (CloudWatch Events)」を選択します。 ルールは「新規ルールの作成」で任意のルール名を入力。ルールタイプをスケジュール式にし、今回は毎日朝5時なのでcorn(0 20 ? * * *)と入力(LambdaはUTCでトリガーされるので9時間前をセットすることに留意)。トリガーを有効にして「追加」をクリックします。（cronの書き方はこちらをご覧ください） テスト最後にしっかり動くかテストしましょう。Lambda関数画面の「テスト」をクリックします。大丈夫そうですね。 おわりに朝の検温はサボっていますが、寝る前にちゃんと測っているので安心してください。 参考文献https://masakimisawa.com/selenium_headless-chrome_python_on_lambda/https://github.com/heroku/heroku-buildpack-google-chrome/issues/56https://qiita.com/mishimay/items/afd7f247f101fbe25f30","link":"/2020/08/11/gfa/"},{"title":"TCPが繋がって切れるまで","text":"最近ふと、「あれ？俺TCP通信理解してなくね？」と思ったので軽くTCPの働きをまとめておきます ソケットを作るアプリケーションでSocketライブラリが呼び出されたタイミングでソケット一つ分のメモリ領域を確保し、制御情報の初期値を記録する。この時点でソケットが一つできたことになるので、このソケットのディスクリプタをアプリケーションに返す。今後アプリケーションがプロトコルスタックにデータ送受信動作を依頼する際にディスクリプタを渡すことで、いちいちアプリケーションが情報を渡す手間を省くことができる。アプリケーションはこのディスクリプタと名前解決で得たサーバーのIPアドレス、IPアドレス内での接続先を示すポート番号を引数にconnect()メソッドを呼び出し、接続フェーズに入る。 サーバーと接続する宛先情報を引数として受け取ったTCPはTCPヘッダーのSYNビットを1にし、ウィンドウサイズやシーケンス番号を記載してサーバーに送信する。サーバー側のTCPは宛先のソケットに接続したらSYN・ACKビットを1にして、サーバー側のウィンドウサイズと乱数で算出したシーケンス番号を記載したTCPヘッダーをつけてクライアントに送り返す。それを受け取ったクライアントのTCPはソケットに制御情報を追加し、再びACKビットを1にしてサーバーに受信確認を送る。この接続動作ではクライアントとサーバー合わせて3回のやりとりで接続が完了するため「3ウェイ・ハンドシェイク」と呼ばれている。 データを送受信する接続が完了したらいよいよデータの送受信に入るが、TCPはMSSに近づくまで送信ようバッファメモリにデータをため、ある程度まで貯まった段階で送信動作に入る。ただ、中々MSSに近づかない場合は送信動作の遅延を招くので、一定時間が経過したら強制的に送信動作が実行される仕様になっているプロトコルスタックがほとんどである。クライアントのTCPはデータを送信する際にシーケンス番号をTCPヘッダーに記載し、サーバーのTCPは受け取ったデータのTCPヘッダーを確認してシーケンス番号＋データのバイト数であるACK番号をクライアントに返す。こうすることでクライアントはサーバーが正常にデータを受け取ったかを確認することができる。 この時、サーバーからACK番号が帰ってくるのをいちいちクライアントが待っていたら通信速度はえげつなく遅くなってしまう。そのため、実際の通信では、接続フェーズで受信側のウィンドウサイズ、つまり受信バッファの空き容量を相手に伝えて置くことでウィンドウサイズに到達するまではACK番号を待つことなくデータを送信できる仕組みになっている。受信側は受信処理が完了して新たにバッファの空き容量が変化したらTCPヘッダーのウィンドウフィールドでウィンドウサイズを通知する。 サーバーから切断するブラウザの場合はサーバーが最後のレスポンスデータを返してデータ送受信が終了するのでサーバー側から切断動作に入るが、クライアントから切断するアプリケーションも存在する。 サーバーは最後のレスポンスメッセージを送信したら、TCPヘッダーのFINビットを１にしたデータをクライアントに送信し、ソケットに切断動作に入ったという情報を記載する。FINビットが1のデータを受け取ったクライアントは同様にソケットに切断動作に入ったという情報を記載し、サーバーにACK番号を返す。その後アプリケーションにデータ受信が終了したという情報を伝え、今度はクライアントからFINビットを1にしたデータをサーバーに送信する。それを受け取ったサーバーはACK番号をクライアントに返し、切断が完了する。 あくまでこの記事はまとめなので実際にデータ送受信の際はもっと他の動作も行われていますが、接続から切断までクライアントとサーバーのTCPさんが行っている仕事を大まかに説明するとこんな感じになります。 もし「こいつ何言ってんだ」と思う部分があれば、ぜひコメントで教えていただけるとありがたいです。","link":"/2020/12/22/tcp/"},{"title":"RSA暗号を計算する","text":"鍵交換アルゴリズムとしてはすでに脆弱性が見つかっており、めっちゃ使われているという実績のみでCRYPTRECの運用監視暗号リストにへばりついているRSA暗号なわけですが、電子署名の、特に署名検証においてはまだまだ現役です。多分。 というわけで、手軽に感動できるRSA暗号の実際の計算をやってみるとともに、最後におまけでRSAがもたらす誤解を紹介したいと思います。 データ受信者が秘密鍵を用意するまずデータ受信者は2つの互いに素な素数p,qを秘密鍵として用意します。実際の実装では1000桁ほどの大きな素数を扱うのですが、この場合は単純化してp = 5, q = 11とします。 当然秘密鍵なのでこの二つの素数は秘密にしておかなければなりません。ブラウザのJavaScriptに書くとかダメ。絶対。 データ受信者が公開鍵を用意する再びデータ受信者が2つの公開鍵を用意します。1つ目は先ほど用意した2つの秘密鍵を掛けた数値n。つまり 1n = p * q = 5 * 11 = 55 もう1つは任意の正の整数eです。実際の通信では2^16 + 1 = 65537が使われることが多いですが、今回は単純化してe = 3とします。 データ受信者が復号のための鍵を用意するまだ終わりではありません。データ受信者は今度は自分に送られてきた暗号文を復号するための鍵dを用意します。具体的な算出方法は以下の通り。 復号鍵dの求め方まず(p-1)と(q-1)の最小公倍数Lを求めます。 ユークリッドの互除法を使ってp-1, q-1の最大公約数gを求めます。今回は4と10の最大公約数なのでg = 2となります。Lはp-1とq-1の最小公倍数なので、 1L = (p - 1) * (q - 1) / g = 4 * 10 / 2 = 20 になります。 ＊今回の場合は簡単な整数なので暗算で最小公倍数を求めることができたかもしれませんが、実際の数値はもっと大きく、ユークリッドの互除法を用いて最大公約数を求めた後にそれを使って最小公倍数を求めることになります。 Lが求まったら、復号鍵dが求まります。復号鍵dの算出方法は 1d = d * e - y * L = 1 の自然解 今回の場合e = 3, L = 20なので 1d = 3d - 20y = 1 の自然解 ∴ d = 7, y = 1 となり、dが7になります。 これで鍵の用意は完了なので、いよいよ暗号と復号に入ります。 平文の暗号化今回は文字列 “RSA” を暗号化したいと思います。まずは”R”を平文mとして暗号化します。暗号化の数式は以下の通りです。 1暗号文c = m^e mod n RをUS-ASCII変換すると52なので 1c = 52^3 mod 55 = 28 この要領で”S”,”A”も暗号化すると、Sは47、Aは6になります。この時点で各バイト数を文字列に変換すると”(G ACK”になり、これが暗号文になります。いい感じに暗号っぽくなってますね。 暗号文の復号上記の方法で送信者が暗号化した文を今度は受信者が復号します。復号の数式は以下の通りです。 1平文m = C^d mod n 一文字ずつ復号してくと、 123456# \"(\"の28を復号28^7 mod 55 = 52# \"G\"の47を復号47^7 mod 55 = 53# \"ACK\"の6を復号6^7 mod 55 = 41 それぞれ文字列に変換すると”RSA”に戻ってますね。ここで確認しておきたいのが、送信者は公開鍵しか使っていないという点です。eもnも一般に公開される公開鍵ですので、送信者も使用できます。一方受信者は秘密鍵であるp,qから作成したLから作成した、実質的に秘密鍵であるdを使って復号をしています。これにより、受信者のみが復号できる暗号通信が完成します。 RSAがもたらす誤解RSAは、一つの公開鍵について秘密鍵が一つに定まる確定的暗号です(文献英語しかなかった…)。固定長のデータを一単位として暗号化するブロック暗号も確定的暗号だったりするのですが、一つの公開鍵についても動的に秘密鍵が変化する確率的暗号も存在します。しかし上述の通りRSA暗号の暗号化と復号の数式が 12c = m^e mod nm = c^d mod n と対になっているがために「暗号アルゴリズムの指数のeとdを逆にすれば署名にも使えるんじゃね？」と一般化した誤解が生まれてしまったのです。しかし、このような暗号化と復号のアルゴリズムにおける対称性があるのはRSA暗号だけであり、なおかつ近年主流になっているECDSAや、主流ですらないDSAやGOSTなど、RSA以外の電子署名暗号方式は公開鍵暗号方式をベースにしたものではありません。よって、「電子署名とは、公開鍵暗号方式の秘密鍵で暗号化することである」というのは紛れもない間違いであることは頭の片隅に置いておいてください。 こんだけイキって書いておいて頓珍漢なこと言っていたらマジで恥ずかしいですが、もし全然違う事言っていたらコメントで教えていただけるとありがたいです。 参考になれば幸いです。 参考http://blog.livedoor.jp/k_urushima/archives/1721840.htmlhttps://qiita.com/angel_p_57/items/d7ffb9ec13b4dde3357dhttps://qiita.com/shoichi0599/items/6082b765c1257b71985bhttps://medium.com/blockchain-engineer-blog/%E7%A7%81%E3%81%AF%E5%85%AC%E9%96%8B%E9%8D%B5%E6%9A%97%E5%8F%B7%E6%96%B9%E5%BC%8F%E3%81%A8%E9%9B%BB%E5%AD%90%E7%BD%B2%E5%90%8D%E3%82%92%E7%90%86%E8%A7%A3%E3%81%A7%E3%81%8D%E3%81%A6%E3%81%84%E3%81%AA%E3%81%8B%E3%81%A3%E3%81%9F%E3%82%88%E3%81%86%E3%81%A7%E3%81%99-af0894c3df0b","link":"/2020/08/18/rsa/"}],"tags":[{"name":"english","slug":"english","link":"/tags/english/"},{"name":"paper","slug":"paper","link":"/tags/paper/"},{"name":"ssi","slug":"ssi","link":"/tags/ssi/"},{"name":"eslint","slug":"eslint","link":"/tags/eslint/"},{"name":"prettier","slug":"prettier","link":"/tags/prettier/"},{"name":"husky","slug":"husky","link":"/tags/husky/"},{"name":"pre-commit","slug":"pre-commit","link":"/tags/pre-commit/"},{"name":"encryption","slug":"encryption","link":"/tags/encryption/"},{"name":"security","slug":"security","link":"/tags/security/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"api","slug":"api","link":"/tags/api/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"matplotlib","slug":"matplotlib","link":"/tags/matplotlib/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"selenium","slug":"selenium","link":"/tags/selenium/"},{"name":"scraping","slug":"scraping","link":"/tags/scraping/"},{"name":"googleform","slug":"googleform","link":"/tags/googleform/"},{"name":"aws","slug":"aws","link":"/tags/aws/"},{"name":"tcp","slug":"tcp","link":"/tags/tcp/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"}],"categories":[{"name":"英語","slug":"英語","link":"/categories/%E8%8B%B1%E8%AA%9E/"},{"name":"論文","slug":"論文","link":"/categories/%E8%AB%96%E6%96%87/"},{"name":"コーディング","slug":"コーディング","link":"/categories/%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0/"},{"name":"ネットワーク","slug":"ネットワーク","link":"/categories/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF/"},{"name":"暗号","slug":"暗号","link":"/categories/%E6%9A%97%E5%8F%B7/"}]}